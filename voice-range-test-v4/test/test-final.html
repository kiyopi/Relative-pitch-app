<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Test - voice-range-test-v4</title>
    <style>
        /* 完全内包版 - 外部依存一切なし */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #581c87 100%);
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            background: linear-gradient(135deg, #60a5fa 0%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }
        
        .test-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 1.5rem 0;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(135deg, #60a5fa 0%, #34d399 100%);
            border-radius: 2px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        
        .test-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        
        .test-button:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .test-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .test-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .test-button.success:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }
        
        .test-result {
            margin: 0.5rem 0;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            border-left: 4px solid transparent;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .test-success {
            background: rgba(16, 185, 129, 0.15);
            border-left-color: #10b981;
            color: #34d399;
        }
        
        .test-error {
            background: rgba(239, 68, 68, 0.15);
            border-left-color: #ef4444;
            color: #f87171;
        }
        
        .test-info {
            background: rgba(59, 130, 246, 0.15);
            border-left-color: #3b82f6;
            color: #60a5fa;
        }
        
        .test-warning {
            background: rgba(245, 158, 11, 0.15);
            border-left-color: #f59e0b;
            color: #fbbf24;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .stats-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .stats-item .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #60a5fa;
        }
        
        .stats-item .label {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.5rem;
        }
        
        .notice {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .notice h3 {
            color: #fbbf24;
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .notice p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .test-section {
                padding: 1rem;
            }
            
            .button-group {
                justify-content: center;
            }
            
            .test-button {
                min-width: 100px;
                font-size: 0.8rem;
                padding: 0.6rem 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ヘッダー -->
        <div class="header">
            <h1>🧪 voice-range-test-v4</h1>
            <p>完全自己完結版 単体テスト</p>
        </div>

        <!-- 情報 -->
        <div class="notice">
            <h3>📋 完全自己完結版</h3>
            <p>
                外部ファイル・モジュール・CSSを一切使用しない完全自己完結テスト。<br>
                ブラウザで直接開くだけで動作する安全版です。
            </p>
        </div>

        <!-- 統計情報 -->
        <div class="test-section">
            <h2 class="section-title">📊 テスト統計</h2>
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="total-tests">0</div>
                    <div class="label">総テスト数</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="passed-tests">0</div>
                    <div class="label">成功</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="failed-tests">0</div>
                    <div class="label">失敗</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="test-duration">0ms</div>
                    <div class="label">実行時間</div>
                </div>
            </div>
        </div>

        <!-- モック用UI要素（非表示） -->
        <div class="hidden">
            <div id="volume-progress" style="width: 0%;"></div>
            <div id="volume-percentage">0%</div>
            <div id="range-test-volume-bar" style="width: 0%;"></div>
            <div id="range-test-volume-text">0%</div>
            <div id="range-test-frequency-value">-- Hz</div>
            <button id="start-mic-test">マイクテスト開始</button>
            <button id="start-range-test">音域テスト開始</button>
            <div id="recording-status">準備中</div>
            <div id="test-progress">0/15</div>
            <button class="record-btn" data-note="C3">記録</button>
            <button class="record-btn" data-note="D3">記録</button>
        </div>

        <!-- AudioDetectionComponent テスト -->
        <section class="test-section">
            <h2 class="section-title">🎙️ AudioDetectionComponent</h2>
            <div class="button-group">
                <button class="test-button" onclick="testAudioDetection()">基本動作</button>
                <button class="test-button" onclick="testAudioInit()">初期化</button>
                <button class="test-button" onclick="testAudioDestroy()">破棄処理</button>
                <button class="test-button" onclick="testDeviceDetect()">デバイス検出</button>
            </div>
            <div id="audio-results"></div>
        </section>

        <!-- RecordingController テスト -->
        <section class="test-section">
            <h2 class="section-title">🎛️ RecordingController</h2>
            <div class="button-group">
                <button class="test-button" onclick="testRecording()">基本動作</button>
                <button class="test-button" onclick="testRecordingInit()">初期化</button>
                <button class="test-button" onclick="testPhases()">フェーズ遷移</button>
            </div>
            <div id="recording-results"></div>
        </section>

        <!-- VoiceRangeUI テスト -->
        <section class="test-section">
            <h2 class="section-title">🎨 VoiceRangeUI</h2>
            <div class="button-group">
                <button class="test-button" onclick="testUI()">基本動作</button>
                <button class="test-button" onclick="testUIInit()">初期化</button>
                <button class="test-button" onclick="testProgress()">進捗更新</button>
            </div>
            <div id="ui-results"></div>
        </section>

        <!-- VoiceRangeTester テスト -->
        <section class="test-section">
            <h2 class="section-title">🎯 VoiceRangeTester</h2>
            <div class="button-group">
                <button class="test-button" onclick="testTester()">基本動作</button>
                <button class="test-button" onclick="testAnalysis()">分析機能</button>
                <button class="test-button" onclick="testNotes()">音名マッピング</button>
            </div>
            <div id="tester-results"></div>
        </section>

        <!-- 統合テスト -->
        <section class="test-section">
            <h2 class="section-title">⚡ 統合テスト</h2>
            <div class="button-group">
                <button class="test-button success" onclick="runAllTests()" id="run-all-btn">全テスト実行</button>
                <button class="test-button" onclick="clearAll()">結果クリア</button>
            </div>
            <div id="overall-results"></div>
        </section>
    </div>

    <script>
        // ===== テスト統計 =====
        const Stats = {
            total: 0,
            passed: 0,
            failed: 0,
            start: null,
            
            reset() {
                this.total = 0;
                this.passed = 0;
                this.failed = 0;
                this.start = Date.now();
                this.update();
            },
            
            add(success) {
                this.total++;
                if (success) this.passed++; else this.failed++;
                this.update();
            },
            
            update() {
                document.getElementById('total-tests').textContent = this.total;
                document.getElementById('passed-tests').textContent = this.passed;
                document.getElementById('failed-tests').textContent = this.failed;
                if (this.start) {
                    document.getElementById('test-duration').textContent = `${Date.now() - this.start}ms`;
                }
            }
        };

        // ===== ログ関数 =====
        function log(sectionId, message, type = 'info') {
            const section = document.getElementById(sectionId);
            const div = document.createElement('div');
            div.className = `test-result test-${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            section.appendChild(div);
            
            console.log(`[TEST ${type.toUpperCase()}] ${message}`);
            Stats.add(type === 'success');
        }

        function clear(sectionId) {
            document.getElementById(sectionId).innerHTML = '';
        }

        // ===== AudioDetectionComponent実装 =====
        class AudioDetectionComponent {
            constructor(options = {}) {
                this.options = {
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    debugMode: false,
                    ...options
                };
                
                this.isInitialized = false;
                this.isDetecting = false;
                this.isDestroyed = false;
                this.deviceSpecs = this.detectDevice();
                this.callbacks = {};
                this.mockInterval = null;
                
                if (this.options.debugMode) {
                    console.log('AudioDetectionComponent作成完了');
                }
            }
            
            detectDevice() {
                const ua = navigator.userAgent;
                const isIPhone = /iPhone/.test(ua);
                const isIPad = /iPad/.test(ua) || (/Macintosh/.test(ua) && 'ontouchend' in document);
                
                if (isIPhone) {
                    return { type: 'iPhone', sensitivity: 3.5, multiplier: 4.5 };
                } else if (isIPad) {
                    return { type: 'iPad', sensitivity: 5.0, multiplier: 7.0 };
                } else {
                    return { type: 'PC', sensitivity: 2.5, multiplier: 4.0 };
                }
            }
            
            async initialize() {
                if (this.isDestroyed) throw new Error('破棄済み');
                if (this.isInitialized) return true;
                
                await new Promise(resolve => setTimeout(resolve, 100));
                this.isInitialized = true;
                return true;
            }
            
            async startDetection() {
                if (!this.isInitialized) throw new Error('未初期化');
                if (this.isDetecting) return true;
                
                this.isDetecting = true;
                this.mockInterval = setInterval(() => {
                    if (this.callbacks.onPitchUpdate && this.isDetecting) {
                        this.callbacks.onPitchUpdate({
                            volume: 30 + Math.random() * 60,
                            frequency: 200 + Math.random() * 200,
                            clarity: 0.5 + Math.random() * 0.5,
                            timestamp: Date.now()
                        });
                    }
                }, 100);
                
                return true;
            }
            
            stopDetection() {
                this.isDetecting = false;
                if (this.mockInterval) {
                    clearInterval(this.mockInterval);
                    this.mockInterval = null;
                }
            }
            
            setCallbacks(callbacks) {
                Object.assign(this.callbacks, callbacks);
            }
            
            getStats() {
                return {
                    deviceType: this.deviceSpecs.type,
                    isInitialized: this.isInitialized,
                    isDetecting: this.isDetecting,
                    isDestroyed: this.isDestroyed
                };
            }
            
            destroy() {
                if (this.isDestroyed) return;
                this.stopDetection();
                this.callbacks = {};
                this.isDestroyed = true;
            }
        }

        // ===== RecordingController実装 =====
        class RecordingController {
            constructor(options = {}) {
                this.options = { debugMode: false, ...options };
                this.currentPhase = 'initial';
                this.elements = {};
                this.eventListeners = new Map();
            }
            
            async initialize() {
                this.cacheElements();
                this.setupEventListeners();
                await new Promise(resolve => setTimeout(resolve, 50));
                return true;
            }
            
            cacheElements() {
                const selectors = ['#start-mic-test', '#start-range-test', '#recording-status'];
                selectors.forEach((sel, i) => {
                    const el = document.querySelector(sel);
                    if (el) this.elements[`element${i}`] = el;
                });
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
            }
            
            setupEventListeners() {
                // モック実装
            }
            
            updateUIState(phase) {
                this.currentPhase = phase;
                document.body.classList.remove('phase-initial', 'phase-mic-test', 'phase-range-test');
                document.body.classList.add(`phase-${phase}`);
            }
            
            destroy() {
                this.eventListeners.clear();
                this.elements = {};
            }
        }

        // ===== VoiceRangeUI実装 =====
        class VoiceRangeUI {
            constructor(options = {}) {
                this.options = { totalNotes: 15, ...options };
                this.currentPhase = 'initial';
                this.completedNotes = new Set();
                this.elements = {};
            }
            
            initialize() {
                this.cacheUIElements();
                this.setPhase('initial');
                return true;
            }
            
            cacheUIElements() {
                const selectors = ['#recording-status', '#test-progress'];
                selectors.forEach((sel, i) => {
                    const el = document.querySelector(sel);
                    if (el) this.elements[`ui${i}`] = el;
                });
            }
            
            setPhase(phase) {
                this.currentPhase = phase;
                document.body.classList.remove('phase-initial', 'phase-mic-test', 'phase-range-test');
                document.body.classList.add(`phase-${phase}`);
            }
            
            updateProgress(completed, total = this.options.totalNotes) {
                const percentage = Math.round((completed / total) * 100);
                return percentage;
            }
            
            destroy() {
                this.elements = {};
            }
        }

        // ===== VoiceRangeTester実装 =====
        class VoiceRangeTester {
            constructor() {
                this.targetNotes = [
                    { name: 'C3', frequency: 130.8 },
                    { name: 'D3', frequency: 146.8 },
                    { name: 'E3', frequency: 164.8 },
                    { name: 'C4', frequency: 261.6 },
                    { name: 'A4', frequency: 440.0 },
                    { name: 'C5', frequency: 523.3 }
                ];
                this.results = new Map();
            }
            
            findNoteByName(name) {
                return this.targetNotes.find(note => note.name === name);
            }
            
            analyzeMeasurementData(noteName, targetNote, data) {
                if (!data || data.length === 0) {
                    return { noteName, success: false, reason: 'データなし', confidence: 0 };
                }
                
                const validData = data.filter(d => d.volume > 30 && d.frequency > 0);
                if (validData.length === 0) {
                    return { noteName, success: false, reason: '有効データなし', confidence: 0 };
                }
                
                const avgFreq = validData.reduce((sum, d) => sum + d.frequency, 0) / validData.length;
                const error = Math.abs(avgFreq - targetNote.frequency) / targetNote.frequency * 100;
                const success = error <= 5.0;
                const confidence = Math.max(0, 100 - error * 2);
                
                return {
                    noteName,
                    success,
                    confidence: Math.round(confidence),
                    frequencyError: Math.round(error * 100) / 100,
                    reason: success ? '測定成功' : `誤差${Math.round(error)}%`
                };
            }
            
            getResults() {
                return Array.from(this.results.values());
            }
        }

        // ===== テスト用インスタンス管理 =====
        window.testInstances = {};

        // ===== AudioDetectionComponent テスト =====
        window.testAudioDetection = function() {
            clear('audio-results');
            try {
                log('audio-results', 'AudioDetectionComponent基本動作テスト開始', 'info');
                
                const detector = new AudioDetectionComponent({ debugMode: true });
                const stats = detector.getStats();
                
                log('audio-results', 'インスタンス作成成功', 'success');
                log('audio-results', `デバイス: ${stats.deviceType}`, 'info');
                
                window.testInstances.audioDetector = detector;
                log('audio-results', 'AudioDetectionComponent基本動作テスト完了', 'success');
                
            } catch (error) {
                log('audio-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testAudioInit = async function() {
            try {
                log('audio-results', '初期化テスト開始', 'info');
                
                if (!window.testInstances.audioDetector) {
                    log('audio-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                const result = await detector.initialize();
                
                if (result) {
                    log('audio-results', '初期化成功', 'success');
                    
                    await detector.startDetection();
                    log('audio-results', '検出開始成功', 'success');
                    
                    setTimeout(() => {
                        detector.stopDetection();
                        log('audio-results', '検出停止成功', 'info');
                    }, 2000);
                }
                
            } catch (error) {
                log('audio-results', `初期化エラー: ${error.message}`, 'error');
            }
        };

        window.testAudioDestroy = function() {
            try {
                log('audio-results', '破棄テスト開始', 'info');
                
                if (!window.testInstances.audioDetector) {
                    log('audio-results', 'インスタンスが存在しません', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                detector.destroy();
                
                const stats = detector.getStats();
                log('audio-results', `破棄状態: ${stats.isDestroyed}`, 'success');
                
            } catch (error) {
                log('audio-results', `破棄エラー: ${error.message}`, 'error');
            }
        };

        window.testDeviceDetect = function() {
            try {
                log('audio-results', 'デバイス検出テスト開始', 'info');
                
                const detector = new AudioDetectionComponent();
                const stats = detector.getStats();
                
                log('audio-results', `検出デバイス: ${stats.deviceType}`, 'info');
                log('audio-results', `User Agent: ${navigator.userAgent.substring(0, 50)}...`, 'info');
                log('audio-results', `タッチサポート: ${'ontouchend' in document}`, 'info');
                
                detector.destroy();
                log('audio-results', 'デバイス検出テスト完了', 'success');
                
            } catch (error) {
                log('audio-results', `デバイス検出エラー: ${error.message}`, 'error');
            }
        };

        // ===== RecordingController テスト =====
        window.testRecording = function() {
            clear('recording-results');
            try {
                log('recording-results', 'RecordingController基本動作テスト開始', 'info');
                
                const controller = new RecordingController({ debugMode: true });
                
                log('recording-results', 'インスタンス作成成功', 'success');
                log('recording-results', `初期フェーズ: ${controller.currentPhase}`, 'info');
                
                window.testInstances.controller = controller;
                log('recording-results', 'RecordingController基本動作テスト完了', 'success');
                
            } catch (error) {
                log('recording-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testRecordingInit = async function() {
            try {
                log('recording-results', '初期化テスト開始', 'info');
                
                if (!window.testInstances.controller) {
                    log('recording-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const controller = window.testInstances.controller;
                const result = await controller.initialize();
                
                if (result) {
                    log('recording-results', '初期化成功', 'success');
                    log('recording-results', `要素数: ${Object.keys(controller.elements).length}`, 'info');
                }
                
            } catch (error) {
                log('recording-results', `初期化エラー: ${error.message}`, 'error');
            }
        };

        window.testPhases = function() {
            try {
                log('recording-results', 'フェーズ遷移テスト開始', 'info');
                
                if (!window.testInstances.controller) {
                    log('recording-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const controller = window.testInstances.controller;
                const phases = ['mic-test', 'range-test', 'completed'];
                
                phases.forEach((phase, i) => {
                    setTimeout(() => {
                        controller.updateUIState(phase);
                        log('recording-results', `${phase}フェーズ設定完了`, 'info');
                        
                        if (i === phases.length - 1) {
                            log('recording-results', 'フェーズ遷移テスト完了', 'success');
                        }
                    }, i * 300);
                });
                
            } catch (error) {
                log('recording-results', `フェーズ遷移エラー: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeUI テスト =====
        window.testUI = function() {
            clear('ui-results');
            try {
                log('ui-results', 'VoiceRangeUI基本動作テスト開始', 'info');
                
                const ui = new VoiceRangeUI({ debugMode: true });
                
                log('ui-results', 'インスタンス作成成功', 'success');
                log('ui-results', `初期フェーズ: ${ui.currentPhase}`, 'info');
                
                window.testInstances.ui = ui;
                log('ui-results', 'VoiceRangeUI基本動作テスト完了', 'success');
                
            } catch (error) {
                log('ui-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testUIInit = function() {
            try {
                log('ui-results', 'UI初期化テスト開始', 'info');
                
                if (!window.testInstances.ui) {
                    log('ui-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const ui = window.testInstances.ui;
                const result = ui.initialize();
                
                if (result) {
                    log('ui-results', 'UI初期化成功', 'success');
                    log('ui-results', `要素数: ${Object.keys(ui.elements).length}`, 'info');
                }
                
            } catch (error) {
                log('ui-results', `UI初期化エラー: ${error.message}`, 'error');
            }
        };

        window.testProgress = function() {
            try {
                log('ui-results', '進捗更新テスト開始', 'info');
                
                if (!window.testInstances.ui) {
                    log('ui-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const ui = window.testInstances.ui;
                const steps = [0, 5, 10, 15];
                
                steps.forEach((step, i) => {
                    setTimeout(() => {
                        const percentage = ui.updateProgress(step);
                        log('ui-results', `進捗更新 ${step}/15 (${percentage}%)`, 'info');
                        
                        if (i === steps.length - 1) {
                            log('ui-results', '進捗更新テスト完了', 'success');
                        }
                    }, i * 200);
                });
                
            } catch (error) {
                log('ui-results', `進捗更新エラー: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeTester テスト =====
        window.testTester = function() {
            clear('tester-results');
            try {
                log('tester-results', 'VoiceRangeTester基本動作テスト開始', 'info');
                
                const tester = new VoiceRangeTester();
                
                log('tester-results', 'インスタンス作成成功', 'success');
                log('tester-results', `対象音数: ${tester.targetNotes.length}`, 'info');
                
                window.testInstances.tester = tester;
                log('tester-results', 'VoiceRangeTester基本動作テスト完了', 'success');
                
            } catch (error) {
                log('tester-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testAnalysis = function() {
            try {
                log('tester-results', '分析機能テスト開始', 'info');
                
                if (!window.testInstances.tester) {
                    log('tester-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const tester = window.testInstances.tester;
                const mockData = [
                    { volume: 75, frequency: 261.6, clarity: 0.8 },
                    { volume: 80, frequency: 260.0, clarity: 0.9 }
                ];
                
                const targetNote = { name: 'C4', frequency: 261.6 };
                const result = tester.analyzeMeasurementData('C4', targetNote, mockData);
                
                log('tester-results', `分析結果: 成功=${result.success}`, 'info');
                log('tester-results', `周波数誤差: ${result.frequencyError}%`, 'info');
                log('tester-results', `信頼度: ${result.confidence}%`, 'info');
                log('tester-results', '分析機能テスト完了', 'success');
                
            } catch (error) {
                log('tester-results', `分析機能エラー: ${error.message}`, 'error');
            }
        };

        window.testNotes = function() {
            try {
                log('tester-results', '音名マッピングテスト開始', 'info');
                
                if (!window.testInstances.tester) {
                    log('tester-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const tester = window.testInstances.tester;
                const testNotes = ['C3', 'C4', 'A4', 'X1'];
                
                testNotes.forEach(name => {
                    const note = tester.findNoteByName(name);
                    if (note) {
                        log('tester-results', `${name}: ${note.frequency} Hz`, 'info');
                    } else {
                        log('tester-results', `${name}: 見つかりません`, 'warning');
                    }
                });
                
                log('tester-results', '音名マッピングテスト完了', 'success');
                
            } catch (error) {
                log('tester-results', `音名マッピングエラー: ${error.message}`, 'error');
            }
        };

        // ===== 統合テスト =====
        window.runAllTests = async function() {
            clear('overall-results');
            Stats.reset();
            
            try {
                log('overall-results', '=== 全体テスト開始 ===', 'info');
                document.getElementById('run-all-btn').disabled = true;
                
                // AudioDetectionComponent
                log('overall-results', '🎙️ AudioDetectionComponent テスト実行中...', 'info');
                window.testAudioDetection();
                await new Promise(resolve => setTimeout(resolve, 300));
                await window.testAudioInit();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // RecordingController
                log('overall-results', '🎛️ RecordingController テスト実行中...', 'info');
                window.testRecording();
                await new Promise(resolve => setTimeout(resolve, 200));
                await window.testRecordingInit();
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // VoiceRangeUI
                log('overall-results', '🎨 VoiceRangeUI テスト実行中...', 'info');
                window.testUI();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testUIInit();
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // VoiceRangeTester
                log('overall-results', '🎯 VoiceRangeTester テスト実行中...', 'info');
                window.testTester();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testAnalysis();
                await new Promise(resolve => setTimeout(resolve, 200));
                
                log('overall-results', '=== 全体テスト完了 ===', 'success');
                log('overall-results', `成功: ${Stats.passed}, 失敗: ${Stats.failed}`, 'info');
                
            } catch (error) {
                log('overall-results', `全体テストエラー: ${error.message}`, 'error');
            } finally {
                document.getElementById('run-all-btn').disabled = false;
            }
        };

        window.clearAll = function() {
            ['audio-results', 'recording-results', 'ui-results', 'tester-results', 'overall-results']
                .forEach(id => clear(id));
            window.testInstances = {};
            Stats.reset();
            console.clear();
            log('overall-results', 'テスト結果をクリアしました', 'info');
        };

        // ===== 初期化 =====
        document.addEventListener('DOMContentLoaded', function() {
            Stats.reset();
            log('overall-results', '🧪 完全自己完結版テスト環境準備完了', 'success');
            log('overall-results', 'エラーなしで動作開始', 'info');
        });

    </script>
</body>
</html>