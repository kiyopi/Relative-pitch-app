<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Test (Standalone) - voice-range-test-v4</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../Bolt/v2/styles/base.css">
    <style>
        .test-container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
        }
        
        .test-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .test-result {
            margin: 0.5rem 0;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .test-success {
            background: rgba(16, 185, 129, 0.2);
            border-left: 4px solid #10b981;
            color: #34d399;
        }
        
        .test-error {
            background: rgba(239, 68, 68, 0.2);
            border-left: 4px solid #ef4444;
            color: #f87171;
        }
        
        .test-info {
            background: rgba(59, 130, 246, 0.2);
            border-left: 4px solid #3b82f6;
            color: #60a5fa;
        }
        
        .test-button {
            margin: 0.5rem;
            padding: 0.5rem 1rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .test-button:hover {
            background: #2563eb;
        }
        
        .test-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        
        .mock-ui-elements {
            display: none;
        }
        
        .cors-notice {
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <header class="mb-6">
            <h1 class="text-2xl font-bold text-white mb-2">voice-range-test-v4 å˜ä½“ãƒ†ã‚¹ãƒˆ (Standaloneç‰ˆ)</h1>
            <p class="text-white-70">CORSå•é¡Œå›é¿ç‰ˆ - å„JavaScriptãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ãƒ†ã‚¹ãƒˆ</p>
        </header>

        <!-- CORSå¯¾å‡¦æƒ…å ± -->
        <div class="cors-notice">
            <h3 class="text-yellow-300 font-medium mb-2">ğŸ“‹ CORSå•é¡Œå¯¾å‡¦ç‰ˆ</h3>
            <p class="text-white-70 text-sm">
                ES6ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å®Ÿè£…ã§CORSå•é¡Œã‚’å›é¿ã—ã¦ã„ã¾ã™ã€‚<br>
                å®Ÿéš›ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†ç¾ã—ãŸãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã™ã€‚
            </p>
        </div>

        <!-- ãƒ¢ãƒƒã‚¯ç”¨UIè¦ç´ ï¼ˆéè¡¨ç¤ºï¼‰ -->
        <div class="mock-ui-elements">
            <div id="volume-progress" style="width: 0%;"></div>
            <div id="volume-percentage">0%</div>
            <div id="range-test-volume-bar" style="width: 0%;"></div>
            <div id="range-test-volume-text">0%</div>
            <div id="range-test-frequency-value">-- Hz</div>
            <button id="start-mic-test">ãƒã‚¤ã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹</button>
            <button id="start-range-test">éŸ³åŸŸãƒ†ã‚¹ãƒˆé–‹å§‹</button>
            <div id="recording-status">æº–å‚™ä¸­</div>
            <div id="test-progress">0/15</div>
            <button class="record-btn" data-note="C3">è¨˜éŒ²</button>
            <button class="record-btn" data-note="D3">è¨˜éŒ²</button>
            <button class="record-btn" data-note="E3">è¨˜éŒ²</button>
        </div>

        <!-- AudioDetectionComponent ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="text-xl font-medium text-white mb-4">
                <i data-lucide="radio" class="inline mr-2"></i>
                AudioDetectionComponent ãƒ†ã‚¹ãƒˆ
            </h2>
            <div class="space-y-2">
                <button class="test-button" onclick="testAudioDetectionComponent()">åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testAudioDetectionInit()">åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testAudioDetectionDestroy()">ç ´æ£„ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testDeviceDetection()">ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div id="audio-detection-results"></div>
        </section>

        <!-- RecordingController ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="text-xl font-medium text-white mb-4">
                <i data-lucide="settings" class="inline mr-2"></i>
                RecordingController ãƒ†ã‚¹ãƒˆ
            </h2>
            <div class="space-y-2">
                <button class="test-button" onclick="testRecordingController()">åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testRecordingControllerInit()">åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testPhaseTransition()">ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testEventHandlers()">ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div id="recording-controller-results"></div>
        </section>

        <!-- VoiceRangeUI ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="text-xl font-medium text-white mb-4">
                <i data-lucide="layout" class="inline mr-2"></i>
                VoiceRangeUI ãƒ†ã‚¹ãƒˆ
            </h2>
            <div class="space-y-2">
                <button class="test-button" onclick="testVoiceRangeUI()">åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testUIElements()">UIè¦ç´ ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testAnimations()">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testProgressUpdate()">é€²æ—æ›´æ–°ãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div id="voice-range-ui-results"></div>
        </section>

        <!-- VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="text-xl font-medium text-white mb-4">
                <i data-lucide="target" class="inline mr-2"></i>
                VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆ
            </h2>
            <div class="space-y-2">
                <button class="test-button" onclick="testVoiceRangeTester()">åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testMeasurement()">æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</button>
                <button class="test-button" onclick="testAnalysis()">åˆ†ææ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</button>
            </div>
            <div id="voice-range-tester-results"></div>
        </section>

        <!-- å…¨ä½“ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="text-xl font-medium text-white mb-4">
                <i data-lucide="check-circle" class="inline mr-2"></i>
                å…¨ä½“ãƒ†ã‚¹ãƒˆ
            </h2>
            <div class="space-y-2">
                <button class="test-button" onclick="runAllTests()" id="run-all-btn">å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="test-button" onclick="clearResults()">çµæœã‚¯ãƒªã‚¢</button>
            </div>
            <div id="overall-results"></div>
        </section>
    </div>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <!-- ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å®Ÿè£…ï¼ˆCORSå•é¡Œå›é¿ï¼‰ -->
    <script>
        // ===== AudioDetectionComponent å†å®Ÿè£… =====
        class AudioDetectionComponent {
            constructor(options = {}) {
                this.options = {
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    frequencySelector: '#frequency-value',
                    clarityThreshold: 0.4,
                    minVolumeAbsolute: 0.003,
                    noiseThreshold: 0.1,
                    enableFrequencyDetection: true,
                    enableVolumeDetection: true,
                    updateInterval: 50,
                    autoDetectDevice: true,
                    debugMode: false,
                    logLevel: 'INFO',
                    ...options
                };
                
                this.audioManager = null;
                this.pitchDetector = null;
                this.volumeBar = null;
                this.volumeText = null;
                this.frequencyElement = null;
                this.isInitialized = false;
                this.isDetecting = false;
                this.isDestroyed = false;
                
                this.callbacks = {
                    onVolumeUpdate: null,
                    onPitchUpdate: null,
                    onError: null,
                    onStateChange: null
                };
                
                this.currentData = {
                    volume: 0,
                    frequency: 0,
                    clarity: 0,
                    timestamp: 0
                };
                
                this.deviceSpecs = this.options.autoDetectDevice ? this.detectDevice() : this.getDefaultSpecs();
                this.errorCount = 0;
                this.lastErrorTime = 0;
                this.maxErrors = 5;
                
                this.log('AudioDetectionComponentåˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            detectDevice() {
                const userAgent = navigator.userAgent;
                const isIPhone = /iPhone/.test(userAgent);
                const isIPad = /iPad/.test(userAgent);
                const isIPadOS = /Macintosh/.test(userAgent) && 'ontouchend' in document;
                const hasIOSNavigator = /iPad|iPhone|iPod/.test(userAgent);
                
                if (isIPhone || hasIOSNavigator) {
                    return {
                        type: 'iPhone',
                        sensitivity: 3.5,
                        volumeBarMultiplier: 4.5,
                        noiseReduction: 0.15
                    };
                } else if (isIPad || isIPadOS) {
                    return {
                        type: 'iPad', 
                        sensitivity: 5.0,
                        volumeBarMultiplier: 7.0,
                        noiseReduction: 0.2
                    };
                } else {
                    return {
                        type: 'PC',
                        sensitivity: 2.5,
                        volumeBarMultiplier: 4.0,
                        noiseReduction: 0.1
                    };
                }
            }
            
            getDefaultSpecs() {
                return {
                    type: 'PC',
                    sensitivity: 2.5,
                    volumeBarMultiplier: 4.0,
                    noiseReduction: 0.1
                };
            }
            
            async initialize() {
                if (this.isDestroyed) {
                    throw new Error('ç ´æ£„ã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å†åˆæœŸåŒ–ã§ãã¾ã›ã‚“');
                }
                
                if (this.isInitialized) {
                    this.log('æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã§ã™', 'WARNING');
                    return true;
                }
                
                try {
                    this.log('åˆæœŸåŒ–é–‹å§‹', 'INFO');
                    this.cacheUIElements();
                    await this.loadPitchProModules();
                    await this.initializeAudioManager();
                    await this.initializePitchDetector();
                    
                    this.isInitialized = true;
                    this.notifyStateChange('initialized');
                    this.log('åˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    return true;
                    
                } catch (error) {
                    this.log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('INITIALIZATION_FAILED', error);
                    throw error;
                }
            }
            
            cacheUIElements() {
                if (this.options.volumeBarSelector) {
                    this.volumeBar = document.querySelector(this.options.volumeBarSelector);
                    if (!this.volumeBar) {
                        this.log(`éŸ³é‡ãƒãƒ¼è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${this.options.volumeBarSelector}`, 'WARNING');
                    }
                }
                
                if (this.options.volumeTextSelector) {
                    this.volumeText = document.querySelector(this.options.volumeTextSelector);
                    if (!this.volumeText) {
                        this.log(`éŸ³é‡ãƒ†ã‚­ã‚¹ãƒˆè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${this.options.volumeTextSelector}`, 'WARNING');
                    }
                }
                
                if (this.options.frequencySelector) {
                    this.frequencyElement = document.querySelector(this.options.frequencySelector);
                    if (!this.frequencyElement) {
                        this.log(`å‘¨æ³¢æ•°è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${this.options.frequencySelector}`, 'WARNING');
                    }
                }
                
                this.log('UIè¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Œäº†', 'INFO');
            }
            
            async loadPitchProModules() {
                try {
                    this.log('PitchProãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ¢ãƒƒã‚¯ç‰ˆï¼‰', 'INFO');
                    
                    // ãƒ¢ãƒƒã‚¯å®Ÿè£…
                    const AudioManager = class {
                        async initialize() { return true; }
                        async startCapture() { return true; }
                        stopCapture() {}
                        destroy() {}
                    };
                    
                    const PitchDetector = class {
                        constructor(options) { 
                            this.options = options; 
                            this.callbacks = {};
                        }
                        setCallbacks(callbacks) { 
                            this.callbacks = callbacks; 
                        }
                        async startDetection() { 
                            this.mockInterval = setInterval(() => {
                                if (this.callbacks.onPitchUpdate) {
                                    this.callbacks.onPitchUpdate({
                                        volume: Math.random() * 100,
                                        frequency: 200 + Math.random() * 200,
                                        clarity: 0.5 + Math.random() * 0.5,
                                        timestamp: Date.now()
                                    });
                                }
                            }, 100);
                            return true; 
                        }
                        stopDetection() { 
                            if (this.mockInterval) {
                                clearInterval(this.mockInterval);
                                this.mockInterval = null;
                            }
                        }
                        destroy() { 
                            this.stopDetection(); 
                        }
                    };
                    
                    this.AudioManager = AudioManager;
                    this.PitchDetector = PitchDetector;
                    this.log('PitchProãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼ˆãƒ¢ãƒƒã‚¯ç‰ˆï¼‰', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`PitchProãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async initializeAudioManager() {
                try {
                    this.audioManager = new this.AudioManager({
                        deviceSpecs: this.deviceSpecs,
                        noiseThreshold: this.options.noiseThreshold,
                        debugMode: this.options.debugMode
                    });
                    
                    await this.audioManager.initialize();
                    await this.audioManager.startCapture();
                    this.log('AudioManageråˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`AudioManageråˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async initializePitchDetector() {
                try {
                    this.pitchDetector = new this.PitchDetector({
                        audioManager: this.audioManager,
                        clarityThreshold: this.options.clarityThreshold,
                        minVolumeAbsolute: this.options.minVolumeAbsolute,
                        sensitivity: this.deviceSpecs.sensitivity,
                        debugMode: this.options.debugMode
                    });
                    
                    this.pitchDetector.setCallbacks({
                        onPitchUpdate: (result) => this.handlePitchUpdate(result),
                        onError: (error) => this.handleError('PITCH_DETECTION_ERROR', error)
                    });
                    
                    this.log('PitchDetectoråˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`PitchDetectoråˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async startDetection() {
                if (!this.isInitialized) {
                    throw new Error('åˆæœŸåŒ–ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“');
                }
                
                if (this.isDetecting) {
                    this.log('æ¤œå‡ºã¯æ—¢ã«é–‹å§‹ã•ã‚Œã¦ã„ã¾ã™', 'WARNING');
                    return true;
                }
                
                try {
                    this.log('æ¤œå‡ºé–‹å§‹', 'INFO');
                    await this.pitchDetector.startDetection();
                    this.isDetecting = true;
                    this.notifyStateChange('detecting');
                    this.log('æ¤œå‡ºé–‹å§‹å®Œäº†', 'SUCCESS');
                    return true;
                    
                } catch (error) {
                    this.log(`æ¤œå‡ºé–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('DETECTION_START_FAILED', error);
                    throw error;
                }
            }
            
            stopDetection() {
                if (!this.isDetecting) {
                    this.log('æ¤œå‡ºã¯æ—¢ã«åœæ­¢ã•ã‚Œã¦ã„ã¾ã™', 'WARNING');
                    return;
                }
                
                try {
                    this.log('æ¤œå‡ºåœæ­¢', 'INFO');
                    if (this.pitchDetector) {
                        this.pitchDetector.stopDetection();
                    }
                    this.isDetecting = false;
                    this.notifyStateChange('stopped');
                    this.log('æ¤œå‡ºåœæ­¢å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`æ¤œå‡ºåœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('DETECTION_STOP_FAILED', error);
                }
            }
            
            handlePitchUpdate(result) {
                try {
                    const volume = result.volume;
                    const frequency = result.frequency || 0;
                    const clarity = result.clarity || 0;
                    const timestamp = result.timestamp || Date.now();
                    
                    this.currentData = { volume, frequency, clarity, timestamp };
                    this.updateVolumeDisplay(volume);
                    
                    if (this.options.enableFrequencyDetection && frequency > 0) {
                        this.updateFrequencyDisplay(frequency);
                    }
                    
                    if (this.callbacks.onVolumeUpdate) {
                        this.callbacks.onVolumeUpdate(result);
                    }
                    
                    if (this.callbacks.onPitchUpdate) {
                        this.callbacks.onPitchUpdate(result);
                    }
                    
                } catch (error) {
                    this.log(`éŸ³å£°ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('DATA_UPDATE_FAILED', error);
                }
            }
            
            updateVolumeDisplay(volume) {
                const displayVolume = Math.min(100, volume * this.deviceSpecs.volumeBarMultiplier);
                
                if (this.volumeBar) {
                    this.volumeBar.style.width = `${Math.max(0, displayVolume)}%`;
                }
                
                if (this.volumeText) {
                    this.volumeText.textContent = `${Math.round(displayVolume)}%`;
                }
            }
            
            updateFrequencyDisplay(frequency) {
                if (this.frequencyElement && frequency > 0) {
                    this.frequencyElement.textContent = `${Math.round(frequency)} Hz`;
                }
            }
            
            setCallbacks(callbacks) {
                if (typeof callbacks.onVolumeUpdate === 'function') {
                    this.callbacks.onVolumeUpdate = callbacks.onVolumeUpdate;
                }
                if (typeof callbacks.onPitchUpdate === 'function') {
                    this.callbacks.onPitchUpdate = callbacks.onPitchUpdate;
                }
                if (typeof callbacks.onError === 'function') {
                    this.callbacks.onError = callbacks.onError;
                }
                if (typeof callbacks.onStateChange === 'function') {
                    this.callbacks.onStateChange = callbacks.onStateChange;
                }
                this.log('ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®šå®Œäº†', 'INFO');
            }
            
            handleError(type, error) {
                this.errorCount++;
                this.lastErrorTime = Date.now();
                
                const errorInfo = {
                    type,
                    message: error?.message || error,
                    count: this.errorCount,
                    timestamp: this.lastErrorTime,
                    deviceType: this.deviceSpecs.type
                };
                
                this.log(`ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ [${type}]: ${errorInfo.message}`, 'ERROR', errorInfo);
                
                if (this.callbacks.onError) {
                    this.callbacks.onError(errorInfo);
                }
                
                if (this.errorCount >= this.maxErrors) {
                    this.log('æœ€å¤§ã‚¨ãƒ©ãƒ¼æ•°ã«é”ã—ã¾ã—ãŸã€‚æ¤œå‡ºã‚’åœæ­¢ã—ã¾ã™', 'ERROR');
                    this.stopDetection();
                }
            }
            
            notifyStateChange(state) {
                if (this.callbacks.onStateChange) {
                    this.callbacks.onStateChange({
                        state,
                        isInitialized: this.isInitialized,
                        isDetecting: this.isDetecting,
                        timestamp: Date.now()
                    });
                }
            }
            
            getCurrentData() {
                return { ...this.currentData };
            }
            
            getStats() {
                return {
                    errorCount: this.errorCount,
                    lastErrorTime: this.lastErrorTime,
                    deviceType: this.deviceSpecs.type,
                    isInitialized: this.isInitialized,
                    isDetecting: this.isDetecting,
                    isDestroyed: this.isDestroyed
                };
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[AudioDetectionComponent ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'WARNING':
                        console.warn(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: green', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                if (this.isDestroyed) {
                    this.log('æ—¢ã«ç ´æ£„ã•ã‚Œã¦ã„ã¾ã™', 'WARNING');
                    return;
                }
                
                try {
                    this.log('ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„é–‹å§‹', 'INFO');
                    this.stopDetection();
                    
                    if (this.pitchDetector) {
                        this.pitchDetector.destroy();
                        this.pitchDetector = null;
                    }
                    
                    if (this.audioManager) {
                        this.audioManager.destroy();
                        this.audioManager = null;
                    }
                    
                    this.callbacks = {};
                    this.volumeBar = null;
                    this.volumeText = null;
                    this.frequencyElement = null;
                    this.isInitialized = false;
                    this.isDetecting = false;
                    this.isDestroyed = true;
                    
                    this.log('ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== ç°¡ç•¥ç‰ˆ RecordingController =====
        class RecordingController {
            constructor(options = {}) {
                this.options = { debugMode: false, ...options };
                this.currentPhase = 'initial';
                this.isRecording = false;
                this.recordingData = [];
                this.currentNote = null;
                this.audioDetector = null;
                this.elements = {};
                this.eventListeners = new Map();
                
                this.log('RecordingControlleråˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            async initialize() {
                try {
                    this.log('åˆæœŸåŒ–é–‹å§‹', 'INFO');
                    this.cacheElements();
                    this.setupEventListeners();
                    this.updateUIState('initial');
                    this.log('åˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            cacheElements() {
                // ç°¡ç•¥ç‰ˆ - åŸºæœ¬è¦ç´ ã®ã¿
                this.elements.micTestButton = document.querySelector('#start-mic-test');
                this.elements.rangeTestStartButton = document.querySelector('#start-range-test');
                this.elements.statusDisplay = document.querySelector('#recording-status');
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
            }
            
            setupEventListeners() {
                // ç°¡ç•¥ç‰ˆ
                this.log('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š', 'INFO');
            }
            
            updateUIState(phase) {
                this.currentPhase = phase;
                document.body.classList.remove('phase-initial', 'phase-mic-test', 'phase-range-test');
                document.body.classList.add(`phase-${phase}`);
                this.log(`ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´: ${phase}`, 'INFO');
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[RecordingController ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: green', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                try {
                    this.log('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹', 'INFO');
                    this.eventListeners.clear();
                    this.log('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†', 'SUCCESS');
                } catch (error) {
                    this.log(`ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== ç°¡ç•¥ç‰ˆ VoiceRangeUI =====
        class VoiceRangeUI {
            constructor(options = {}) {
                this.options = { 
                    enableAnimations: true,
                    totalNotes: 15,
                    debugMode: false, 
                    ...options 
                };
                this.currentPhase = 'initial';
                this.completedNotes = new Set();
                this.elements = {};
                this.animations = {};
                
                this.log('VoiceRangeUIåˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            initialize() {
                try {
                    this.log('UIåˆæœŸåŒ–é–‹å§‹', 'INFO');
                    this.cacheUIElements();
                    this.setPhase('initial');
                    this.updateProgress(0, this.options.totalNotes);
                    this.log('UIåˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`UIåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            cacheUIElements() {
                // ç°¡ç•¥ç‰ˆ
                this.elements.statusDisplay = document.querySelector('#recording-status');
                this.elements.progressDisplay = document.querySelector('#test-progress');
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
                this.log(`UIè¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Œäº†: ${Object.keys(this.elements).length}å€‹`, 'INFO');
            }
            
            setPhase(phase) {
                this.log(`ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´: ${this.currentPhase} â†’ ${phase}`, 'INFO');
                const previousPhase = this.currentPhase;
                this.currentPhase = phase;
                
                const body = document.body;
                body.classList.remove(`phase-${previousPhase}`);
                body.classList.add(`phase-${phase}`);
            }
            
            updateProgress(completed, total = this.options.totalNotes) {
                const percentage = Math.round((completed / total) * 100);
                if (this.elements.progressDisplay) {
                    this.elements.progressDisplay.textContent = `é€²æ—: ${completed}/${total}éŸ³åŸŸ`;
                }
                this.log(`é€²æ—æ›´æ–°: ${completed}/${total} (${percentage}%)`, 'INFO');
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[VoiceRangeUI ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: green', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                try {
                    this.log('UIã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹', 'INFO');
                    this.elements = {};
                    this.log('UIã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†', 'SUCCESS');
                } catch (error) {
                    this.log(`UIã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== ç°¡ç•¥ç‰ˆ VoiceRangeTesterV113 =====
        class VoiceRangeTesterV113 {
            constructor(options = {}) {
                this.options = {
                    targetNotes: [
                        { name: 'C3', frequency: 130.8 },
                        { name: 'D3', frequency: 146.8 },
                        { name: 'E3', frequency: 164.8 },
                        { name: 'F3', frequency: 174.6 },
                        { name: 'G3', frequency: 196.0 },
                        { name: 'A3', frequency: 220.0 },
                        { name: 'B3', frequency: 246.9 },
                        { name: 'C4', frequency: 261.6 },
                        { name: 'D4', frequency: 293.7 },
                        { name: 'E4', frequency: 329.6 },
                        { name: 'F4', frequency: 349.2 },
                        { name: 'G4', frequency: 392.0 },
                        { name: 'A4', frequency: 440.0 },
                        { name: 'B4', frequency: 493.9 },
                        { name: 'C5', frequency: 523.3 }
                    ],
                    tolerancePercent: 5.0,
                    minRecordingDuration: 2.0,
                    ...options
                };
                
                this.results = new Map();
                this.audioDetector = null;
                
                this.log('VoiceRangeTesterV113åˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            setAudioDetector(audioDetector) {
                this.audioDetector = audioDetector;
            }
            
            analyzeMeasurementData(noteName, targetNote, data) {
                if (data.length === 0) {
                    return { noteName, success: false, reason: 'ãƒ‡ãƒ¼ã‚¿ãªã—', confidence: 0 };
                }
                
                const validData = data.filter(d => d.volume > 30 && d.frequency > 0 && d.clarity > 0.4);
                
                if (validData.length === 0) {
                    return { noteName, success: false, reason: 'æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ãªã—', confidence: 0 };
                }
                
                const avgFrequency = validData.reduce((sum, d) => sum + d.frequency, 0) / validData.length;
                const avgVolume = validData.reduce((sum, d) => sum + d.volume, 0) / validData.length;
                const avgClarity = validData.reduce((sum, d) => sum + d.clarity, 0) / validData.length;
                
                const frequencyError = Math.abs(avgFrequency - targetNote.frequency) / targetNote.frequency * 100;
                const isAccurate = frequencyError <= this.options.tolerancePercent;
                const confidence = Math.max(0, 100 - frequencyError * 2) * (avgClarity / 1.0) * (Math.min(avgVolume, 100) / 100);
                
                return {
                    noteName,
                    targetFrequency: targetNote.frequency,
                    measuredFrequency: avgFrequency,
                    frequencyError: frequencyError,
                    avgVolume,
                    avgClarity,
                    confidence,
                    success: isAccurate && confidence > 60,
                    reason: isAccurate ? 'æ¸¬å®šæˆåŠŸ' : `å‘¨æ³¢æ•°èª¤å·®: ${frequencyError.toFixed(1)}%`
                };
            }
            
            getResults() {
                return Array.from(this.results.values());
            }
            
            log(message, level = 'INFO', data = null) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[VoiceRangeTesterV113 ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: green', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
        }

        // ===== ãƒ†ã‚¹ãƒˆç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° =====
        window.testInstances = {};
        window.testResults = [];

        // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° =====
        function logResult(sectionId, message, type = 'info') {
            const section = document.getElementById(sectionId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result test-${type}`;
            resultDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            section.appendChild(resultDiv);
            console.log(`[TEST ${type.toUpperCase()}] ${message}`);
        }

        function clearSectionResults(sectionId) {
            const section = document.getElementById(sectionId);
            section.innerHTML = '';
        }

        // ===== AudioDetectionComponent ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testAudioDetectionComponent = async function() {
            clearSectionResults('audio-detection-results');
            try {
                logResult('audio-detection-results', 'AudioDetectionComponentåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const detector = new AudioDetectionComponent({
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    debugMode: true
                });
                
                logResult('audio-detection-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                
                const stats = detector.getStats();
                logResult('audio-detection-results', `ãƒ‡ãƒã‚¤ã‚¹: ${stats.deviceType}`, 'info');
                
                window.testInstances.audioDetector = detector;
                logResult('audio-detection-results', 'AudioDetectionComponentåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAudioDetectionInit = async function() {
            try {
                logResult('audio-detection-results', 'åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.audioDetector) {
                    logResult('audio-detection-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                const result = await detector.initialize();
                
                if (result) {
                    logResult('audio-detection-results', 'åˆæœŸåŒ–æˆåŠŸ', 'success');
                    
                    const stats = detector.getStats();
                    logResult('audio-detection-results', `åˆæœŸåŒ–çŠ¶æ…‹: ${stats.isInitialized}`, 'info');
                } else {
                    logResult('audio-detection-results', 'åˆæœŸåŒ–å¤±æ•—', 'error');
                }
                
            } catch (error) {
                logResult('audio-detection-results', `åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAudioDetectionDestroy = function() {
            try {
                logResult('audio-detection-results', 'ç ´æ£„ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.audioDetector) {
                    logResult('audio-detection-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                detector.destroy();
                
                const stats = detector.getStats();
                logResult('audio-detection-results', `ç ´æ£„çŠ¶æ…‹: ${stats.isDestroyed}`, 'success');
                
                detector.destroy();
                logResult('audio-detection-results', 'é‡è¤‡ç ´æ£„ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `ç ´æ£„ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testDeviceDetection = function() {
            try {
                logResult('audio-detection-results', 'ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const detector = new AudioDetectionComponent({ debugMode: true });
                const stats = detector.getStats();
                
                logResult('audio-detection-results', `æ¤œå‡ºãƒ‡ãƒã‚¤ã‚¹: ${stats.deviceType}`, 'info');
                logResult('audio-detection-results', navigator.userAgent.substring(0, 50) + '...', 'info');
                
                const hasTouch = 'ontouchend' in document;
                logResult('audio-detection-results', `ã‚¿ãƒƒãƒã‚µãƒãƒ¼ãƒˆ: ${hasTouch}`, 'info');
                
                detector.destroy();
                logResult('audio-detection-results', 'ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== RecordingController ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testRecordingController = function() {
            clearSectionResults('recording-controller-results');
            try {
                logResult('recording-controller-results', 'RecordingControlleråŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const controller = new RecordingController({ debugMode: true });
                
                logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                logResult('recording-controller-results', `åˆæœŸãƒ•ã‚§ãƒ¼ã‚º: ${controller.currentPhase}`, 'info');
                
                window.testInstances.recordingController = controller;
                logResult('recording-controller-results', 'RecordingControlleråŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testRecordingControllerInit = async function() {
            try {
                logResult('recording-controller-results', 'åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                const result = await controller.initialize();
                
                if (result) {
                    logResult('recording-controller-results', 'åˆæœŸåŒ–æˆåŠŸ', 'success');
                    logResult('recording-controller-results', `UIè¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ•°: ${Object.keys(controller.elements).length}`, 'info');
                } else {
                    logResult('recording-controller-results', 'åˆæœŸåŒ–å¤±æ•—', 'error');
                }
                
            } catch (error) {
                logResult('recording-controller-results', `åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testPhaseTransition = function() {
            try {
                logResult('recording-controller-results', 'ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                
                controller.updateUIState('mic-test');
                logResult('recording-controller-results', `mic-testãƒ•ã‚§ãƒ¼ã‚º: ${controller.currentPhase}`, 'info');
                
                controller.updateUIState('range-test');
                logResult('recording-controller-results', `range-testãƒ•ã‚§ãƒ¼ã‚º: ${controller.currentPhase}`, 'info');
                
                logResult('recording-controller-results', 'ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testEventHandlers = function() {
            try {
                logResult('recording-controller-results', 'ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                const listenerCount = controller.eventListeners.size;
                logResult('recording-controller-results', `ç™»éŒ²ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼æ•°: ${listenerCount}`, 'info');
                logResult('recording-controller-results', 'ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeUI ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testVoiceRangeUI = function() {
            clearSectionResults('voice-range-ui-results');
            try {
                logResult('voice-range-ui-results', 'VoiceRangeUIåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const ui = new VoiceRangeUI({
                    enableAnimations: false,
                    debugMode: true
                });
                
                logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                logResult('voice-range-ui-results', `åˆæœŸãƒ•ã‚§ãƒ¼ã‚º: ${ui.currentPhase}`, 'info');
                
                window.testInstances.voiceRangeUI = ui;
                logResult('voice-range-ui-results', 'VoiceRangeUIåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-ui-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testUIElements = function() {
            try {
                logResult('voice-range-ui-results', 'UIè¦ç´ ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                const result = ui.initialize();
                
                if (result) {
                    logResult('voice-range-ui-results', 'UIåˆæœŸåŒ–æˆåŠŸ', 'success');
                    logResult('voice-range-ui-results', `ã‚­ãƒ£ãƒƒã‚·ãƒ¥UIè¦ç´ æ•°: ${Object.keys(ui.elements).length}`, 'info');
                } else {
                    logResult('voice-range-ui-results', 'UIåˆæœŸåŒ–å¤±æ•—', 'error');
                }
                
            } catch (error) {
                logResult('voice-range-ui-results', `UIè¦ç´ ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAnimations = function() {
            try {
                logResult('voice-range-ui-results', 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                
                ui.setPhase('mic-test');
                logResult('voice-range-ui-results', 'mic-testãƒ•ã‚§ãƒ¼ã‚ºè¨­å®šå®Œäº†', 'info');
                
                ui.setPhase('range-test');
                logResult('voice-range-ui-results', 'range-testãƒ•ã‚§ãƒ¼ã‚ºè¨­å®šå®Œäº†', 'info');
                
                logResult('voice-range-ui-results', 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-ui-results', `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testProgressUpdate = function() {
            try {
                logResult('voice-range-ui-results', 'é€²æ—æ›´æ–°ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                
                ui.updateProgress(5, 15);
                logResult('voice-range-ui-results', 'é€²æ—æ›´æ–° 5/15 å®Œäº†', 'info');
                
                ui.updateProgress(10, 15);
                logResult('voice-range-ui-results', 'é€²æ—æ›´æ–° 10/15 å®Œäº†', 'info');
                
                ui.updateProgress(15, 15);
                logResult('voice-range-ui-results', 'é€²æ—æ›´æ–° 15/15 å®Œäº†', 'info');
                
                logResult('voice-range-ui-results', 'é€²æ—æ›´æ–°ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-ui-results', `é€²æ—æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testVoiceRangeTester = function() {
            clearSectionResults('voice-range-tester-results');
            try {
                logResult('voice-range-tester-results', 'VoiceRangeTesterV113åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const tester = new VoiceRangeTesterV113();
                
                logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                logResult('voice-range-tester-results', `å¯¾è±¡éŸ³æ•°: ${tester.options.targetNotes.length}`, 'info');
                
                window.testInstances.voiceRangeTester = tester;
                logResult('voice-range-tester-results', 'VoiceRangeTesterV113åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testMeasurement = function() {
            try {
                logResult('voice-range-tester-results', 'æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                const mockDetector = {
                    setCallbacks: (callbacks) => {
                        setTimeout(() => {
                            callbacks.onPitchUpdate({
                                volume: 75,
                                frequency: 261.6,
                                clarity: 0.8,
                                timestamp: Date.now()
                            });
                        }, 100);
                    }
                };
                
                tester.setAudioDetector(mockDetector);
                logResult('voice-range-tester-results', 'ãƒ¢ãƒƒã‚¯AudioDetectorè¨­å®šå®Œäº†', 'info');
                logResult('voice-range-tester-results', 'æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `æ¸¬å®šæ©Ÿèƒ½ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAnalysis = function() {
            try {
                logResult('voice-range-tester-results', 'åˆ†ææ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                const mockData = [
                    { volume: 75, frequency: 261.6, clarity: 0.8, timestamp: Date.now() },
                    { volume: 80, frequency: 260.0, clarity: 0.9, timestamp: Date.now() + 100 },
                    { volume: 85, frequency: 263.0, clarity: 0.7, timestamp: Date.now() + 200 }
                ];
                
                const targetNote = { name: 'C4', frequency: 261.6 };
                const result = tester.analyzeMeasurementData('C4', targetNote, mockData);
                
                logResult('voice-range-tester-results', `åˆ†æçµæœ: ${result.success}`, 'info');
                logResult('voice-range-tester-results', `å‘¨æ³¢æ•°èª¤å·®: ${result.frequencyError?.toFixed(2)}%`, 'info');
                logResult('voice-range-tester-results', `ä¿¡é ¼åº¦: ${result.confidence?.toFixed(1)}%`, 'info');
                
                logResult('voice-range-tester-results', 'åˆ†ææ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `åˆ†ææ©Ÿèƒ½ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== å…¨ä½“ãƒ†ã‚¹ãƒˆ =====
        window.runAllTests = async function() {
            clearSectionResults('overall-results');
            const startTime = Date.now();
            
            try {
                logResult('overall-results', 'å…¨ä½“ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                document.getElementById('run-all-btn').disabled = true;
                
                await window.testAudioDetectionComponent();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                window.testRecordingController();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                window.testVoiceRangeUI();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                window.testVoiceRangeTester();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                logResult('overall-results', `å…¨ä½“ãƒ†ã‚¹ãƒˆå®Œäº† (${duration}ms)`, 'success');
                logResult('overall-results', 'ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„', 'info');
                
            } catch (error) {
                logResult('overall-results', `å…¨ä½“ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                document.getElementById('run-all-btn').disabled = false;
            }
        };

        window.clearResults = function() {
            const sections = [
                'audio-detection-results',
                'recording-controller-results', 
                'voice-range-ui-results',
                'voice-range-tester-results',
                'overall-results'
            ];
            
            sections.forEach(sectionId => clearSectionResults(sectionId));
            window.testInstances = {};
            console.clear();
        };

        // ===== åˆæœŸåŒ– =====
        document.addEventListener('DOMContentLoaded', function() {
            lucide.createIcons();
            logResult('overall-results', 'å˜ä½“ãƒ†ã‚¹ãƒˆç’°å¢ƒæº–å‚™å®Œäº†ï¼ˆCORSå•é¡Œå›é¿ç‰ˆï¼‰', 'success');
        });

    </script>
</body>
</html>