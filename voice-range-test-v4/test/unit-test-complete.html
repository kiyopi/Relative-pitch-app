<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Unit Test - voice-range-test-v4</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* 完全スタンドアロン版 - CSSも内包 */
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        .test-container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 2rem;
        }
        
        .test-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }
        
        .test-result {
            margin: 0.5rem 0;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-left: 4px solid transparent;
        }
        
        .test-success {
            background: rgba(16, 185, 129, 0.15);
            border-left-color: #10b981;
            color: #34d399;
        }
        
        .test-error {
            background: rgba(239, 68, 68, 0.15);
            border-left-color: #ef4444;
            color: #f87171;
        }
        
        .test-info {
            background: rgba(59, 130, 246, 0.15);
            border-left-color: #3b82f6;
            color: #60a5fa;
        }
        
        .test-warning {
            background: rgba(245, 158, 11, 0.15);
            border-left-color: #f59e0b;
            color: #fbbf24;
        }
        
        .test-button {
            margin: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .test-button:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .test-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .test-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .test-button.success:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            background: linear-gradient(135deg, #60a5fa 0%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 1.5rem 0;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(135deg, #60a5fa 0%, #34d399 100%);
            border-radius: 2px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .cors-notice {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .cors-notice h3 {
            color: #fbbf24;
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .cors-notice p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .mock-ui-elements {
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .stats-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .stats-item .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #60a5fa;
        }
        
        .stats-item .label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.5rem;
        }
        
        @media (max-width: 768px) {
            .test-container {
                margin: 1rem;
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .test-section {
                padding: 1rem;
            }
            
            .button-group {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="test-container">
        <!-- ヘッダー -->
        <div class="header">
            <h1>🧪 voice-range-test-v4</h1>
            <p>完全スタンドアロン版 単体テスト</p>
        </div>

        <!-- CORS対処情報 -->
        <div class="cors-notice">
            <h3>📋 完全スタンドアロン版</h3>
            <p>
                全てのコードとスタイルを内包し、外部ファイル依存を完全に排除。<br>
                CORSエラーなしで直接ブラウザで動作するテスト環境です。
            </p>
        </div>

        <!-- 統計情報 -->
        <div class="test-section">
            <h2 class="section-title">📊 テスト統計</h2>
            <div class="stats-grid" id="stats-grid">
                <div class="stats-item">
                    <div class="value" id="total-tests">0</div>
                    <div class="label">総テスト数</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="passed-tests">0</div>
                    <div class="label">成功</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="failed-tests">0</div>
                    <div class="label">失敗</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="test-duration">0ms</div>
                    <div class="label">実行時間</div>
                </div>
            </div>
        </div>

        <!-- モック用UI要素（非表示） -->
        <div class="mock-ui-elements">
            <div id="volume-progress" style="width: 0%;"></div>
            <div id="volume-percentage">0%</div>
            <div id="range-test-volume-bar" style="width: 0%;"></div>
            <div id="range-test-volume-text">0%</div>
            <div id="range-test-frequency-value">-- Hz</div>
            <button id="start-mic-test">マイクテスト開始</button>
            <button id="start-range-test">音域テスト開始</button>
            <div id="recording-status">準備中</div>
            <div id="test-progress">0/15</div>
            <button class="record-btn" data-note="C3">記録</button>
            <button class="record-btn" data-note="D3">記録</button>
            <button class="record-btn" data-note="E3">記録</button>
        </div>

        <!-- AudioDetectionComponent テスト -->
        <section class="test-section">
            <h2 class="section-title">🎙️ AudioDetectionComponent</h2>
            <div class="button-group">
                <button class="test-button" onclick="testAudioDetectionComponent()">基本動作</button>
                <button class="test-button" onclick="testAudioDetectionInit()">初期化</button>
                <button class="test-button" onclick="testAudioDetectionDestroy()">破棄処理</button>
                <button class="test-button" onclick="testDeviceDetection()">デバイス検出</button>
                <button class="test-button" onclick="testCallbacks()">コールバック</button>
            </div>
            <div id="audio-detection-results"></div>
        </section>

        <!-- RecordingController テスト -->
        <section class="test-section">
            <h2 class="section-title">🎛️ RecordingController</h2>
            <div class="button-group">
                <button class="test-button" onclick="testRecordingController()">基本動作</button>
                <button class="test-button" onclick="testRecordingControllerInit()">初期化</button>
                <button class="test-button" onclick="testPhaseTransition()">フェーズ遷移</button>
                <button class="test-button" onclick="testEventHandlers()">イベント処理</button>
            </div>
            <div id="recording-controller-results"></div>
        </section>

        <!-- VoiceRangeUI テスト -->
        <section class="test-section">
            <h2 class="section-title">🎨 VoiceRangeUI</h2>
            <div class="button-group">
                <button class="test-button" onclick="testVoiceRangeUI()">基本動作</button>
                <button class="test-button" onclick="testUIElements()">UI要素</button>
                <button class="test-button" onclick="testAnimations()">アニメーション</button>
                <button class="test-button" onclick="testProgressUpdate()">進捗更新</button>
            </div>
            <div id="voice-range-ui-results"></div>
        </section>

        <!-- VoiceRangeTesterV113 テスト -->
        <section class="test-section">
            <h2 class="section-title">🎯 VoiceRangeTesterV113</h2>
            <div class="button-group">
                <button class="test-button" onclick="testVoiceRangeTester()">基本動作</button>
                <button class="test-button" onclick="testMeasurement()">測定機能</button>
                <button class="test-button" onclick="testAnalysis()">分析機能</button>
                <button class="test-button" onclick="testNoteMapping()">音名マッピング</button>
            </div>
            <div id="voice-range-tester-results"></div>
        </section>

        <!-- 統合テスト -->
        <section class="test-section">
            <h2 class="section-title">⚡ 統合テスト</h2>
            <div class="button-group">
                <button class="test-button success" onclick="runAllTests()" id="run-all-btn">全テスト実行</button>
                <button class="test-button" onclick="runCriticalTests()">重要テストのみ</button>
                <button class="test-button" onclick="clearResults()">結果クリア</button>
                <button class="test-button" onclick="exportResults()">結果エクスポート</button>
            </div>
            <div id="overall-results"></div>
        </section>
    </div>

    <script>
        // ===== テスト統計管理 =====
        const TestStats = {
            total: 0,
            passed: 0,
            failed: 0,
            startTime: null,
            
            reset() {
                this.total = 0;
                this.passed = 0;
                this.failed = 0;
                this.startTime = Date.now();
                this.updateDisplay();
            },
            
            addResult(success) {
                this.total++;
                if (success) {
                    this.passed++;
                } else {
                    this.failed++;
                }
                this.updateDisplay();
            },
            
            updateDisplay() {
                document.getElementById('total-tests').textContent = this.total;
                document.getElementById('passed-tests').textContent = this.passed;
                document.getElementById('failed-tests').textContent = this.failed;
                
                if (this.startTime) {
                    const duration = Date.now() - this.startTime;
                    document.getElementById('test-duration').textContent = `${duration}ms`;
                }
            }
        };

        // ===== AudioDetectionComponent 完全実装 =====
        class AudioDetectionComponent {
            constructor(options = {}) {
                this.options = {
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    frequencySelector: '#frequency-value',
                    clarityThreshold: 0.4,
                    minVolumeAbsolute: 0.003,
                    noiseThreshold: 0.1,
                    enableFrequencyDetection: true,
                    enableVolumeDetection: true,
                    updateInterval: 50,
                    autoDetectDevice: true,
                    debugMode: false,
                    logLevel: 'INFO',
                    ...options
                };
                
                this.audioManager = null;
                this.pitchDetector = null;
                this.volumeBar = null;
                this.volumeText = null;
                this.frequencyElement = null;
                this.isInitialized = false;
                this.isDetecting = false;
                this.isDestroyed = false;
                
                this.callbacks = {
                    onVolumeUpdate: null,
                    onPitchUpdate: null,
                    onError: null,
                    onStateChange: null
                };
                
                this.currentData = {
                    volume: 0,
                    frequency: 0,
                    clarity: 0,
                    timestamp: 0
                };
                
                this.deviceSpecs = this.options.autoDetectDevice ? this.detectDevice() : this.getDefaultSpecs();
                this.errorCount = 0;
                this.lastErrorTime = 0;
                this.maxErrors = 5;
                
                this.log('AudioDetectionComponent初期化完了', 'SUCCESS');
            }
            
            detectDevice() {
                const userAgent = navigator.userAgent;
                const isIPhone = /iPhone/.test(userAgent);
                const isIPad = /iPad/.test(userAgent);
                const isIPadOS = /Macintosh/.test(userAgent) && 'ontouchend' in document;
                const hasIOSNavigator = /iPad|iPhone|iPod/.test(userAgent);
                
                if (isIPhone || hasIOSNavigator) {
                    return {
                        type: 'iPhone',
                        sensitivity: 3.5,
                        volumeBarMultiplier: 4.5,
                        noiseReduction: 0.15
                    };
                } else if (isIPad || isIPadOS) {
                    return {
                        type: 'iPad', 
                        sensitivity: 5.0,
                        volumeBarMultiplier: 7.0,
                        noiseReduction: 0.2
                    };
                } else {
                    return {
                        type: 'PC',
                        sensitivity: 2.5,
                        volumeBarMultiplier: 4.0,
                        noiseReduction: 0.1
                    };
                }
            }
            
            getDefaultSpecs() {
                return {
                    type: 'PC',
                    sensitivity: 2.5,
                    volumeBarMultiplier: 4.0,
                    noiseReduction: 0.1
                };
            }
            
            async initialize() {
                if (this.isDestroyed) {
                    throw new Error('破棄されたインスタンスは再初期化できません');
                }
                
                if (this.isInitialized) {
                    this.log('既に初期化済みです', 'WARNING');
                    return true;
                }
                
                try {
                    this.log('初期化開始', 'INFO');
                    this.cacheUIElements();
                    await this.loadPitchProModules();
                    await this.initializeAudioManager();
                    await this.initializePitchDetector();
                    
                    this.isInitialized = true;
                    this.notifyStateChange('initialized');
                    this.log('初期化完了', 'SUCCESS');
                    return true;
                    
                } catch (error) {
                    this.log(`初期化エラー: ${error.message}`, 'ERROR');
                    this.handleError('INITIALIZATION_FAILED', error);
                    throw error;
                }
            }
            
            cacheUIElements() {
                if (this.options.volumeBarSelector) {
                    this.volumeBar = document.querySelector(this.options.volumeBarSelector);
                    if (!this.volumeBar) {
                        this.log(`音量バー要素が見つかりません: ${this.options.volumeBarSelector}`, 'WARNING');
                    }
                }
                
                if (this.options.volumeTextSelector) {
                    this.volumeText = document.querySelector(this.options.volumeTextSelector);
                    if (!this.volumeText) {
                        this.log(`音量テキスト要素が見つかりません: ${this.options.volumeTextSelector}`, 'WARNING');
                    }
                }
                
                if (this.options.frequencySelector) {
                    this.frequencyElement = document.querySelector(this.options.frequencySelector);
                    if (!this.frequencyElement) {
                        this.log(`周波数要素が見つかりません: ${this.options.frequencySelector}`, 'WARNING');
                    }
                }
                
                this.log('UI要素キャッシュ完了', 'INFO');
            }
            
            async loadPitchProModules() {
                try {
                    this.log('PitchProモジュールロード（テスト版モック）', 'INFO');
                    
                    // 高度なモック実装
                    const AudioManager = class {
                        constructor(options) {
                            this.options = options;
                            this.isActive = false;
                        }
                        
                        async initialize() { 
                            await new Promise(resolve => setTimeout(resolve, 100)); // 非同期処理シミュレーション
                            return true; 
                        }
                        
                        async startCapture() { 
                            this.isActive = true;
                            return true; 
                        }
                        
                        stopCapture() {
                            this.isActive = false;
                        }
                        
                        destroy() {
                            this.stopCapture();
                        }
                        
                        getState() {
                            return { isActive: this.isActive };
                        }
                    };
                    
                    const PitchDetector = class {
                        constructor(options) { 
                            this.options = options; 
                            this.callbacks = {};
                            this.mockInterval = null;
                            this.isDetecting = false;
                        }
                        
                        setCallbacks(callbacks) { 
                            this.callbacks = callbacks; 
                        }
                        
                        async startDetection() { 
                            this.isDetecting = true;
                            // より現実的なモックデータ生成
                            this.mockInterval = setInterval(() => {
                                if (this.callbacks.onPitchUpdate && this.isDetecting) {
                                    // 音域に応じた周波数生成
                                    const baseFreq = 200;
                                    const variation = (Math.random() - 0.5) * 50;
                                    const frequency = baseFreq + variation;
                                    
                                    // 音量の変動
                                    const baseVolume = 30 + Math.random() * 60;
                                    const volume = Math.max(0, Math.min(100, baseVolume));
                                    
                                    // 明瞭度の計算
                                    const clarity = 0.3 + Math.random() * 0.7;
                                    
                                    this.callbacks.onPitchUpdate({
                                        volume,
                                        frequency,
                                        clarity,
                                        timestamp: Date.now()
                                    });
                                }
                            }, 100);
                            return true; 
                        }
                        
                        stopDetection() { 
                            this.isDetecting = false;
                            if (this.mockInterval) {
                                clearInterval(this.mockInterval);
                                this.mockInterval = null;
                            }
                        }
                        
                        destroy() { 
                            this.stopDetection(); 
                        }
                        
                        getState() {
                            return { 
                                isDetecting: this.isDetecting,
                                hasInterval: !!this.mockInterval 
                            };
                        }
                    };
                    
                    this.AudioManager = AudioManager;
                    this.PitchDetector = PitchDetector;
                    this.log('PitchProモジュールロード完了（テスト版モック）', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`PitchProモジュールロードエラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async initializeAudioManager() {
                try {
                    this.audioManager = new this.AudioManager({
                        deviceSpecs: this.deviceSpecs,
                        noiseThreshold: this.options.noiseThreshold,
                        debugMode: this.options.debugMode
                    });
                    
                    await this.audioManager.initialize();
                    await this.audioManager.startCapture();
                    this.log('AudioManager初期化完了', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`AudioManager初期化エラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async initializePitchDetector() {
                try {
                    this.pitchDetector = new this.PitchDetector({
                        audioManager: this.audioManager,
                        clarityThreshold: this.options.clarityThreshold,
                        minVolumeAbsolute: this.options.minVolumeAbsolute,
                        sensitivity: this.deviceSpecs.sensitivity,
                        debugMode: this.options.debugMode
                    });
                    
                    this.pitchDetector.setCallbacks({
                        onPitchUpdate: (result) => this.handlePitchUpdate(result),
                        onError: (error) => this.handleError('PITCH_DETECTION_ERROR', error)
                    });
                    
                    this.log('PitchDetector初期化完了', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`PitchDetector初期化エラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async startDetection() {
                if (!this.isInitialized) {
                    throw new Error('初期化が完了していません');
                }
                
                if (this.isDetecting) {
                    this.log('検出は既に開始されています', 'WARNING');
                    return true;
                }
                
                try {
                    this.log('検出開始', 'INFO');
                    await this.pitchDetector.startDetection();
                    this.isDetecting = true;
                    this.notifyStateChange('detecting');
                    this.log('検出開始完了', 'SUCCESS');
                    return true;
                    
                } catch (error) {
                    this.log(`検出開始エラー: ${error.message}`, 'ERROR');
                    this.handleError('DETECTION_START_FAILED', error);
                    throw error;
                }
            }
            
            stopDetection() {
                if (!this.isDetecting) {
                    this.log('検出は既に停止されています', 'WARNING');
                    return;
                }
                
                try {
                    this.log('検出停止', 'INFO');
                    if (this.pitchDetector) {
                        this.pitchDetector.stopDetection();
                    }
                    this.isDetecting = false;
                    this.notifyStateChange('stopped');
                    this.log('検出停止完了', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`検出停止エラー: ${error.message}`, 'ERROR');
                    this.handleError('DETECTION_STOP_FAILED', error);
                }
            }
            
            handlePitchUpdate(result) {
                try {
                    const volume = result.volume;
                    const frequency = result.frequency || 0;
                    const clarity = result.clarity || 0;
                    const timestamp = result.timestamp || Date.now();
                    
                    this.currentData = { volume, frequency, clarity, timestamp };
                    this.updateVolumeDisplay(volume);
                    
                    if (this.options.enableFrequencyDetection && frequency > 0) {
                        this.updateFrequencyDisplay(frequency);
                    }
                    
                    if (this.callbacks.onVolumeUpdate) {
                        this.callbacks.onVolumeUpdate(result);
                    }
                    
                    if (this.callbacks.onPitchUpdate) {
                        this.callbacks.onPitchUpdate(result);
                    }
                    
                } catch (error) {
                    this.log(`音声データ更新エラー: ${error.message}`, 'ERROR');
                    this.handleError('DATA_UPDATE_FAILED', error);
                }
            }
            
            updateVolumeDisplay(volume) {
                const displayVolume = Math.min(100, volume * this.deviceSpecs.volumeBarMultiplier);
                
                if (this.volumeBar) {
                    this.volumeBar.style.width = `${Math.max(0, displayVolume)}%`;
                }
                
                if (this.volumeText) {
                    this.volumeText.textContent = `${Math.round(displayVolume)}%`;
                }
            }
            
            updateFrequencyDisplay(frequency) {
                if (this.frequencyElement && frequency > 0) {
                    this.frequencyElement.textContent = `${Math.round(frequency)} Hz`;
                }
            }
            
            setCallbacks(callbacks) {
                Object.keys(callbacks).forEach(key => {
                    if (typeof callbacks[key] === 'function' && this.callbacks.hasOwnProperty(key)) {
                        this.callbacks[key] = callbacks[key];
                    }
                });
                this.log('コールバック設定完了', 'INFO');
            }
            
            handleError(type, error) {
                this.errorCount++;
                this.lastErrorTime = Date.now();
                
                const errorInfo = {
                    type,
                    message: error?.message || error,
                    count: this.errorCount,
                    timestamp: this.lastErrorTime,
                    deviceType: this.deviceSpecs.type
                };
                
                this.log(`エラー発生 [${type}]: ${errorInfo.message}`, 'ERROR', errorInfo);
                
                if (this.callbacks.onError) {
                    this.callbacks.onError(errorInfo);
                }
                
                if (this.errorCount >= this.maxErrors) {
                    this.log('最大エラー数に達しました。検出を停止します', 'ERROR');
                    this.stopDetection();
                }
            }
            
            notifyStateChange(state) {
                if (this.callbacks.onStateChange) {
                    this.callbacks.onStateChange({
                        state,
                        isInitialized: this.isInitialized,
                        isDetecting: this.isDetecting,
                        timestamp: Date.now()
                    });
                }
            }
            
            getCurrentData() {
                return { ...this.currentData };
            }
            
            getStats() {
                return {
                    errorCount: this.errorCount,
                    lastErrorTime: this.lastErrorTime,
                    deviceType: this.deviceSpecs.type,
                    isInitialized: this.isInitialized,
                    isDetecting: this.isDetecting,
                    isDestroyed: this.isDestroyed,
                    audioManager: this.audioManager?.getState?.() || null,
                    pitchDetector: this.pitchDetector?.getState?.() || null
                };
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[AudioDetectionComponent ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'WARNING':
                        console.warn(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                if (this.isDestroyed) {
                    this.log('既に破棄されています', 'WARNING');
                    return;
                }
                
                try {
                    this.log('リソース破棄開始', 'INFO');
                    this.stopDetection();
                    
                    if (this.pitchDetector) {
                        this.pitchDetector.destroy();
                        this.pitchDetector = null;
                    }
                    
                    if (this.audioManager) {
                        this.audioManager.destroy();
                        this.audioManager = null;
                    }
                    
                    this.callbacks = {};
                    this.volumeBar = null;
                    this.volumeText = null;
                    this.frequencyElement = null;
                    this.isInitialized = false;
                    this.isDetecting = false;
                    this.isDestroyed = true;
                    
                    this.log('リソース破棄完了', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`リソース破棄エラー: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== 簡略版 RecordingController =====
        class RecordingController {
            constructor(options = {}) {
                this.options = { debugMode: false, ...options };
                this.currentPhase = 'initial';
                this.isRecording = false;
                this.recordingData = [];
                this.currentNote = null;
                this.audioDetector = null;
                this.elements = {};
                this.eventListeners = new Map();
                
                this.log('RecordingController初期化完了', 'SUCCESS');
            }
            
            async initialize() {
                try {
                    this.log('初期化開始', 'INFO');
                    this.cacheElements();
                    this.setupEventListeners();
                    this.updateUIState('initial');
                    this.log('初期化完了', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`初期化エラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            cacheElements() {
                const selectors = {
                    micTestButton: '#start-mic-test',
                    rangeTestStartButton: '#start-range-test', 
                    statusDisplay: '#recording-status',
                    progressDisplay: '#test-progress'
                };
                
                Object.keys(selectors).forEach(key => {
                    const element = document.querySelector(selectors[key]);
                    if (element) {
                        this.elements[key] = element;
                    }
                });
                
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
                this.log(`要素キャッシュ完了: ${Object.keys(this.elements).length}個`, 'INFO');
            }
            
            setupEventListeners() {
                this.log('イベントリスナー設定', 'INFO');
                // 実際の実装では各要素にイベントリスナーを設定
            }
            
            updateUIState(phase) {
                const previousPhase = this.currentPhase;
                this.currentPhase = phase;
                
                document.body.classList.remove(`phase-${previousPhase}`);
                document.body.classList.add(`phase-${phase}`);
                
                this.log(`フェーズ変更: ${previousPhase} → ${phase}`, 'INFO');
            }
            
            async startMicTest() {
                try {
                    this.log('マイクテスト開始', 'INFO');
                    this.updateUIState('mic-test');
                    
                    // モックでの非同期処理
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    this.log('マイクテスト完了', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`マイクテストエラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async startRangeTest() {
                try {
                    this.log('音域テスト開始', 'INFO');
                    this.updateUIState('range-test');
                    
                    // モックでの非同期処理
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    this.log('音域テスト準備完了', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`音域テストエラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[RecordingController ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                try {
                    this.log('クリーンアップ開始', 'INFO');
                    this.eventListeners.clear();
                    this.elements = {};
                    this.log('クリーンアップ完了', 'SUCCESS');
                } catch (error) {
                    this.log(`クリーンアップエラー: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== 簡略版 VoiceRangeUI =====
        class VoiceRangeUI {
            constructor(options = {}) {
                this.options = { 
                    enableAnimations: true,
                    totalNotes: 15,
                    debugMode: false, 
                    ...options 
                };
                this.currentPhase = 'initial';
                this.completedNotes = new Set();
                this.elements = {};
                this.animations = {};
                
                this.log('VoiceRangeUI初期化完了', 'SUCCESS');
            }
            
            initialize() {
                try {
                    this.log('UI初期化開始', 'INFO');
                    this.cacheUIElements();
                    this.setPhase('initial');
                    this.updateProgress(0, this.options.totalNotes);
                    this.log('UI初期化完了', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`UI初期化エラー: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            cacheUIElements() {
                const selectors = {
                    statusDisplay: '#recording-status',
                    progressDisplay: '#test-progress',
                    micTestButton: '#start-mic-test',
                    rangeStartButton: '#start-range-test'
                };
                
                Object.keys(selectors).forEach(key => {
                    const element = document.querySelector(selectors[key]);
                    if (element) {
                        this.elements[key] = element;
                    }
                });
                
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
                this.log(`UI要素キャッシュ完了: ${Object.keys(this.elements).length}個`, 'INFO');
            }
            
            setPhase(phase) {
                this.log(`フェーズ変更: ${this.currentPhase} → ${phase}`, 'INFO');
                const previousPhase = this.currentPhase;
                this.currentPhase = phase;
                
                const body = document.body;
                body.classList.remove(`phase-${previousPhase}`);
                body.classList.add(`phase-${phase}`);
                
                // フェーズ変更のアニメーション
                if (this.options.enableAnimations) {
                    this.playPhaseTransitionAnimation(previousPhase, phase);
                }
            }
            
            playPhaseTransitionAnimation(from, to) {
                this.log(`アニメーション実行: ${from} → ${to}`, 'INFO');
                // アニメーション実装はモック
            }
            
            updateProgress(completed, total = this.options.totalNotes) {
                const percentage = Math.round((completed / total) * 100);
                
                if (this.elements.progressDisplay) {
                    this.elements.progressDisplay.textContent = `進捗: ${completed}/${total}音域 (${percentage}%)`;
                }
                
                this.log(`進捗更新: ${completed}/${total} (${percentage}%)`, 'INFO');
                return percentage;
            }
            
            updateStatus(message, type = 'info') {
                if (this.elements.statusDisplay) {
                    this.elements.statusDisplay.textContent = message;
                    this.elements.statusDisplay.className = `status status-${type}`;
                }
                this.log(`ステータス更新: ${message}`, 'INFO');
            }
            
            startRecordingAnimation(noteIndex) {
                this.log(`記録アニメーション開始: Note ${noteIndex}`, 'INFO');
                if (this.elements.recordButtons[noteIndex]) {
                    this.elements.recordButtons[noteIndex].classList.add('recording');
                }
            }
            
            stopRecordingAnimation(noteIndex, success = true) {
                this.log(`記録アニメーション停止: Note ${noteIndex}, 成功: ${success}`, 'INFO');
                if (this.elements.recordButtons[noteIndex]) {
                    const button = this.elements.recordButtons[noteIndex];
                    button.classList.remove('recording');
                    button.classList.add(success ? 'success' : 'failed');
                }
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[VoiceRangeUI ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                try {
                    this.log('UIクリーンアップ開始', 'INFO');
                    
                    // アニメーション停止
                    Object.keys(this.animations).forEach(key => {
                        if (this.animations[key]) {
                            clearInterval(this.animations[key]);
                        }
                    });
                    
                    this.elements = {};
                    this.log('UIクリーンアップ完了', 'SUCCESS');
                } catch (error) {
                    this.log(`UIクリーンアップエラー: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== VoiceRangeTesterV113 実装 =====
        class VoiceRangeTesterV113 {
            constructor(options = {}) {
                this.options = {
                    targetNotes: [
                        { name: 'C3', frequency: 130.8 },
                        { name: 'D3', frequency: 146.8 },
                        { name: 'E3', frequency: 164.8 },
                        { name: 'F3', frequency: 174.6 },
                        { name: 'G3', frequency: 196.0 },
                        { name: 'A3', frequency: 220.0 },
                        { name: 'B3', frequency: 246.9 },
                        { name: 'C4', frequency: 261.6 },
                        { name: 'D4', frequency: 293.7 },
                        { name: 'E4', frequency: 329.6 },
                        { name: 'F4', frequency: 349.2 },
                        { name: 'G4', frequency: 392.0 },
                        { name: 'A4', frequency: 440.0 },
                        { name: 'B4', frequency: 493.9 },
                        { name: 'C5', frequency: 523.3 }
                    ],
                    tolerancePercent: 5.0,
                    minRecordingDuration: 2.0,
                    ...options
                };
                
                this.results = new Map();
                this.audioDetector = null;
                
                this.log('VoiceRangeTesterV113初期化完了', 'SUCCESS');
            }
            
            setAudioDetector(audioDetector) {
                this.audioDetector = audioDetector;
                this.log('AudioDetector設定完了', 'INFO');
            }
            
            findNoteByName(noteName) {
                return this.options.targetNotes.find(note => note.name === noteName);
            }
            
            async measureRange(noteName, duration = 3000) {
                if (!this.audioDetector) {
                    throw new Error('AudioDetectionComponentが設定されていません');
                }
                
                const targetNote = this.findNoteByName(noteName);
                if (!targetNote) {
                    throw new Error(`未対応の音名: ${noteName}`);
                }
                
                const measurementData = [];
                const startTime = Date.now();
                
                return new Promise((resolve) => {
                    const collectData = (result) => {
                        measurementData.push({
                            volume: result.volume,
                            frequency: result.frequency,
                            clarity: result.clarity,
                            timestamp: result.timestamp
                        });
                    };
                    
                    this.audioDetector.setCallbacks({
                        onPitchUpdate: collectData
                    });
                    
                    setTimeout(() => {
                        const result = this.analyzeMeasurementData(noteName, targetNote, measurementData);
                        this.results.set(noteName, result);
                        resolve(result);
                    }, duration);
                });
            }
            
            analyzeMeasurementData(noteName, targetNote, data) {
                if (data.length === 0) {
                    return {
                        noteName,
                        success: false,
                        reason: 'データなし',
                        confidence: 0,
                        dataCount: 0
                    };
                }
                
                const validData = data.filter(d => d.volume > 30 && d.frequency > 0 && d.clarity > 0.4);
                
                if (validData.length === 0) {
                    return {
                        noteName,
                        success: false,
                        reason: '有効なデータなし',
                        confidence: 0,
                        dataCount: data.length,
                        validDataCount: 0
                    };
                }
                
                const avgFrequency = validData.reduce((sum, d) => sum + d.frequency, 0) / validData.length;
                const avgVolume = validData.reduce((sum, d) => sum + d.volume, 0) / validData.length;
                const avgClarity = validData.reduce((sum, d) => sum + d.clarity, 0) / validData.length;
                
                const frequencyError = Math.abs(avgFrequency - targetNote.frequency) / targetNote.frequency * 100;
                const isAccurate = frequencyError <= this.options.tolerancePercent;
                
                // 信頼度計算の改善
                const accuracyScore = Math.max(0, 100 - frequencyError * 2);
                const clarityScore = (avgClarity / 1.0) * 100;
                const volumeScore = (Math.min(avgVolume, 100) / 100) * 100;
                const confidence = (accuracyScore * 0.5 + clarityScore * 0.3 + volumeScore * 0.2);
                
                return {
                    noteName,
                    targetFrequency: targetNote.frequency,
                    measuredFrequency: avgFrequency,
                    frequencyError: frequencyError,
                    avgVolume,
                    avgClarity,
                    confidence,
                    success: isAccurate && confidence > 60,
                    reason: isAccurate ? '測定成功' : `周波数誤差: ${frequencyError.toFixed(1)}%`,
                    dataCount: data.length,
                    validDataCount: validData.length,
                    accuracyScore,
                    clarityScore,
                    volumeScore
                };
            }
            
            getResults() {
                return Array.from(this.results.values());
            }
            
            getResultByNote(noteName) {
                return this.results.get(noteName);
            }
            
            clearResults() {
                this.results.clear();
                this.log('測定結果をクリアしました', 'INFO');
            }
            
            getStatistics() {
                const results = this.getResults();
                if (results.length === 0) {
                    return { totalMeasurements: 0 };
                }
                
                const successful = results.filter(r => r.success);
                const avgConfidence = results.reduce((sum, r) => sum + r.confidence, 0) / results.length;
                const avgFrequencyError = results.reduce((sum, r) => sum + r.frequencyError, 0) / results.length;
                
                return {
                    totalMeasurements: results.length,
                    successfulMeasurements: successful.length,
                    successRate: (successful.length / results.length) * 100,
                    avgConfidence,
                    avgFrequencyError,
                    bestResult: results.reduce((best, current) => 
                        current.confidence > best.confidence ? current : best, results[0]),
                    worstResult: results.reduce((worst, current) => 
                        current.confidence < worst.confidence ? current : worst, results[0])
                };
            }
            
            log(message, level = 'INFO', data = null) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[VoiceRangeTesterV113 ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
        }

        // ===== テスト用グローバル変数 =====
        window.testInstances = {};
        window.testResults = [];

        // ===== ユーティリティ関数 =====
        function logResult(sectionId, message, type = 'info') {
            const section = document.getElementById(sectionId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result test-${type}`;
            resultDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            section.appendChild(resultDiv);
            
            console.log(`[TEST ${type.toUpperCase()}] ${message}`);
            TestStats.addResult(type === 'success' || type === 'info');
        }

        function clearSectionResults(sectionId) {
            const section = document.getElementById(sectionId);
            section.innerHTML = '';
        }

        // ===== AudioDetectionComponent テスト関数群 =====
        window.testAudioDetectionComponent = async function() {
            clearSectionResults('audio-detection-results');
            try {
                logResult('audio-detection-results', 'AudioDetectionComponent基本動作テスト開始', 'info');
                
                const detector = new AudioDetectionComponent({
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    debugMode: true
                });
                
                logResult('audio-detection-results', 'インスタンス作成成功', 'success');
                
                const stats = detector.getStats();
                logResult('audio-detection-results', `デバイス: ${stats.deviceType}`, 'info');
                logResult('audio-detection-results', `初期化状態: ${stats.isInitialized}`, 'info');
                logResult('audio-detection-results', `検出状態: ${stats.isDetecting}`, 'info');
                
                window.testInstances.audioDetector = detector;
                logResult('audio-detection-results', 'AudioDetectionComponent基本動作テスト完了', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testAudioDetectionInit = async function() {
            try {
                logResult('audio-detection-results', '初期化テスト開始', 'info');
                
                if (!window.testInstances.audioDetector) {
                    logResult('audio-detection-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                const result = await detector.initialize();
                
                if (result) {
                    logResult('audio-detection-results', '初期化成功', 'success');
                    
                    const stats = detector.getStats();
                    logResult('audio-detection-results', `初期化状態: ${stats.isInitialized}`, 'info');
                    
                    // 検出開始テスト
                    await detector.startDetection();
                    logResult('audio-detection-results', '検出開始成功', 'success');
                    
                    // 3秒後に停止
                    setTimeout(() => {
                        detector.stopDetection();
                        logResult('audio-detection-results', '検出停止成功', 'info');
                    }, 3000);
                    
                } else {
                    logResult('audio-detection-results', '初期化失敗', 'error');
                }
                
            } catch (error) {
                logResult('audio-detection-results', `初期化エラー: ${error.message}`, 'error');
            }
        };

        window.testAudioDetectionDestroy = function() {
            try {
                logResult('audio-detection-results', '破棄テスト開始', 'info');
                
                if (!window.testInstances.audioDetector) {
                    logResult('audio-detection-results', 'インスタンスが存在しません', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                detector.destroy();
                
                const stats = detector.getStats();
                logResult('audio-detection-results', `破棄状態: ${stats.isDestroyed}`, 'success');
                
                // 重複破棄テスト
                detector.destroy();
                logResult('audio-detection-results', '重複破棄テスト完了（警告が表示されるべき）', 'info');
                
            } catch (error) {
                logResult('audio-detection-results', `破棄エラー: ${error.message}`, 'error');
            }
        };

        window.testDeviceDetection = function() {
            try {
                logResult('audio-detection-results', 'デバイス検出テスト開始', 'info');
                
                const detector = new AudioDetectionComponent({ debugMode: true });
                const stats = detector.getStats();
                
                logResult('audio-detection-results', `検出デバイス: ${stats.deviceType}`, 'info');
                logResult('audio-detection-results', `User Agent: ${navigator.userAgent.substring(0, 80)}...`, 'info');
                
                const hasTouch = 'ontouchend' in document;
                logResult('audio-detection-results', `タッチサポート: ${hasTouch}`, 'info');
                
                const platform = navigator.platform;
                logResult('audio-detection-results', `プラットフォーム: ${platform}`, 'info');
                
                detector.destroy();
                logResult('audio-detection-results', 'デバイス検出テスト完了', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `デバイス検出エラー: ${error.message}`, 'error');
            }
        };

        window.testCallbacks = async function() {
            try {
                logResult('audio-detection-results', 'コールバックテスト開始', 'info');
                
                const detector = new AudioDetectionComponent({ debugMode: true });
                
                let volumeUpdateCount = 0;
                let pitchUpdateCount = 0;
                let stateChangeCount = 0;
                
                detector.setCallbacks({
                    onVolumeUpdate: (result) => {
                        volumeUpdateCount++;
                    },
                    onPitchUpdate: (result) => {
                        pitchUpdateCount++;
                    },
                    onStateChange: (state) => {
                        stateChangeCount++;
                        logResult('audio-detection-results', `状態変更: ${state.state}`, 'info');
                    }
                });
                
                await detector.initialize();
                await detector.startDetection();
                
                // 2秒待機してコールバック実行回数をチェック
                setTimeout(() => {
                    detector.stopDetection();
                    logResult('audio-detection-results', `音量更新コールバック: ${volumeUpdateCount}回`, 'info');
                    logResult('audio-detection-results', `音程更新コールバック: ${pitchUpdateCount}回`, 'info');
                    logResult('audio-detection-results', `状態変更コールバック: ${stateChangeCount}回`, 'info');
                    
                    if (pitchUpdateCount > 0) {
                        logResult('audio-detection-results', 'コールバックテスト成功', 'success');
                    } else {
                        logResult('audio-detection-results', 'コールバック実行回数が少なすぎます', 'warning');
                    }
                    
                    detector.destroy();
                }, 2000);
                
            } catch (error) {
                logResult('audio-detection-results', `コールバックエラー: ${error.message}`, 'error');
            }
        };

        // ===== RecordingController テスト関数群 =====
        window.testRecordingController = function() {
            clearSectionResults('recording-controller-results');
            try {
                logResult('recording-controller-results', 'RecordingController基本動作テスト開始', 'info');
                
                const controller = new RecordingController({ debugMode: true });
                
                logResult('recording-controller-results', 'インスタンス作成成功', 'success');
                logResult('recording-controller-results', `初期フェーズ: ${controller.currentPhase}`, 'info');
                logResult('recording-controller-results', `記録状態: ${controller.isRecording}`, 'info');
                
                window.testInstances.recordingController = controller;
                logResult('recording-controller-results', 'RecordingController基本動作テスト完了', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testRecordingControllerInit = async function() {
            try {
                logResult('recording-controller-results', '初期化テスト開始', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                const result = await controller.initialize();
                
                if (result) {
                    logResult('recording-controller-results', '初期化成功', 'success');
                    logResult('recording-controller-results', `UI要素キャッシュ数: ${Object.keys(controller.elements).length}`, 'info');
                    
                    // 機能テスト
                    await controller.startMicTest();
                    logResult('recording-controller-results', 'マイクテスト機能テスト完了', 'success');
                    
                    await controller.startRangeTest();
                    logResult('recording-controller-results', '音域テスト機能テスト完了', 'success');
                    
                } else {
                    logResult('recording-controller-results', '初期化失敗', 'error');
                }
                
            } catch (error) {
                logResult('recording-controller-results', `初期化エラー: ${error.message}`, 'error');
            }
        };

        window.testPhaseTransition = function() {
            try {
                logResult('recording-controller-results', 'フェーズ遷移テスト開始', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                
                const phases = ['initial', 'mic-test', 'range-test', 'completed'];
                phases.forEach((phase, index) => {
                    setTimeout(() => {
                        controller.updateUIState(phase);
                        logResult('recording-controller-results', `${phase}フェーズ: ${controller.currentPhase}`, 'info');
                        
                        if (index === phases.length - 1) {
                            logResult('recording-controller-results', 'フェーズ遷移テスト完了', 'success');
                        }
                    }, index * 500);
                });
                
            } catch (error) {
                logResult('recording-controller-results', `フェーズ遷移エラー: ${error.message}`, 'error');
            }
        };

        window.testEventHandlers = function() {
            try {
                logResult('recording-controller-results', 'イベント処理テスト開始', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                const listenerCount = controller.eventListeners.size;
                logResult('recording-controller-results', `登録イベントリスナー数: ${listenerCount}`, 'info');
                
                // 要素の存在確認
                const elementCount = Object.keys(controller.elements).length;
                logResult('recording-controller-results', `キャッシュ要素数: ${elementCount}`, 'info');
                
                logResult('recording-controller-results', 'イベント処理テスト完了', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `イベント処理エラー: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeUI テスト関数群 =====
        window.testVoiceRangeUI = function() {
            clearSectionResults('voice-range-ui-results');
            try {
                logResult('voice-range-ui-results', 'VoiceRangeUI基本動作テスト開始', 'info');
                
                const ui = new VoiceRangeUI({
                    enableAnimations: false,
                    debugMode: true
                });
                
                logResult('voice-range-ui-results', 'インスタンス作成成功', 'success');
                logResult('voice-range-ui-results', `初期フェーズ: ${ui.currentPhase}`, 'info');
                logResult('voice-range-ui-results', `アニメーション設定: ${ui.options.enableAnimations}`, 'info');
                
                window.testInstances.voiceRangeUI = ui;
                logResult('voice-range-ui-results', 'VoiceRangeUI基本動作テスト完了', 'success');
                
            } catch (error) {
                logResult('voice-range-ui-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testUIElements = function() {
            try {
                logResult('voice-range-ui-results', 'UI要素テスト開始', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                const result = ui.initialize();
                
                if (result) {
                    logResult('voice-range-ui-results', 'UI初期化成功', 'success');
                    logResult('voice-range-ui-results', `キャッシュUI要素数: ${Object.keys(ui.elements).length}`, 'info');
                    
                    // ステータス更新テスト
                    ui.updateStatus('テスト中...', 'info');
                    logResult('voice-range-ui-results', 'ステータス更新テスト完了', 'success');
                    
                } else {
                    logResult('voice-range-ui-results', 'UI初期化失敗', 'error');
                }
                
            } catch (error) {
                logResult('voice-range-ui-results', `UI要素エラー: ${error.message}`, 'error');
            }
        };

        window.testAnimations = function() {
            try {
                logResult('voice-range-ui-results', 'アニメーションテスト開始', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                
                const phases = ['mic-test', 'range-test', 'completed'];
                phases.forEach((phase, index) => {
                    setTimeout(() => {
                        ui.setPhase(phase);
                        logResult('voice-range-ui-results', `${phase}フェーズ設定完了`, 'info');
                        
                        if (index === phases.length - 1) {
                            logResult('voice-range-ui-results', 'アニメーションテスト完了', 'success');
                        }
                    }, index * 300);
                });
                
                // 記録アニメーションテスト
                setTimeout(() => {
                    ui.startRecordingAnimation(0);
                    logResult('voice-range-ui-results', '記録アニメーション開始', 'info');
                    
                    setTimeout(() => {
                        ui.stopRecordingAnimation(0, true);
                        logResult('voice-range-ui-results', '記録アニメーション停止（成功）', 'success');
                    }, 1000);
                }, 1000);
                
            } catch (error) {
                logResult('voice-range-ui-results', `アニメーションエラー: ${error.message}`, 'error');
            }
        };

        window.testProgressUpdate = function() {
            try {
                logResult('voice-range-ui-results', '進捗更新テスト開始', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                
                const progressSteps = [
                    { completed: 0, total: 15 },
                    { completed: 5, total: 15 },
                    { completed: 10, total: 15 },
                    { completed: 15, total: 15 }
                ];
                
                progressSteps.forEach((step, index) => {
                    setTimeout(() => {
                        const percentage = ui.updateProgress(step.completed, step.total);
                        logResult('voice-range-ui-results', `進捗更新 ${step.completed}/${step.total} (${percentage}%) 完了`, 'info');
                        
                        if (index === progressSteps.length - 1) {
                            logResult('voice-range-ui-results', '進捗更新テスト完了', 'success');
                        }
                    }, index * 200);
                });
                
            } catch (error) {
                logResult('voice-range-ui-results', `進捗更新エラー: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeTesterV113 テスト関数群 =====
        window.testVoiceRangeTester = function() {
            clearSectionResults('voice-range-tester-results');
            try {
                logResult('voice-range-tester-results', 'VoiceRangeTesterV113基本動作テスト開始', 'info');
                
                const tester = new VoiceRangeTesterV113();
                
                logResult('voice-range-tester-results', 'インスタンス作成成功', 'success');
                logResult('voice-range-tester-results', `対象音数: ${tester.options.targetNotes.length}`, 'info');
                logResult('voice-range-tester-results', `許容誤差: ${tester.options.tolerancePercent}%`, 'info');
                
                window.testInstances.voiceRangeTester = tester;
                logResult('voice-range-tester-results', 'VoiceRangeTesterV113基本動作テスト完了', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `エラー: ${error.message}`, 'error');
            }
        };

        window.testMeasurement = function() {
            try {
                logResult('voice-range-tester-results', '測定機能テスト開始', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                // モック AudioDetectionComponent作成
                const mockDetector = {
                    setCallbacks: (callbacks) => {
                        logResult('voice-range-tester-results', 'モックコールバック設定完了', 'info');
                        
                        // モックデータで測定シミュレーション
                        setTimeout(() => {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    callbacks.onPitchUpdate({
                                        volume: 75 + Math.random() * 20,
                                        frequency: 261.6 + (Math.random() - 0.5) * 10, // C4周辺
                                        clarity: 0.8 + Math.random() * 0.2,
                                        timestamp: Date.now()
                                    });
                                }, i * 100);
                            }
                        }, 100);
                    }
                };
                
                tester.setAudioDetector(mockDetector);
                logResult('voice-range-tester-results', 'モックAudioDetector設定完了', 'info');
                logResult('voice-range-tester-results', '測定機能テスト完了', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `測定機能エラー: ${error.message}`, 'error');
            }
        };

        window.testAnalysis = function() {
            try {
                logResult('voice-range-tester-results', '分析機能テスト開始', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                // 複数パターンのモック測定データでテスト
                const testCases = [
                    {
                        name: '成功ケース',
                        data: [
                            { volume: 75, frequency: 261.6, clarity: 0.8, timestamp: Date.now() },
                            { volume: 80, frequency: 260.0, clarity: 0.9, timestamp: Date.now() + 100 },
                            { volume: 85, frequency: 263.0, clarity: 0.7, timestamp: Date.now() + 200 }
                        ]
                    },
                    {
                        name: '失敗ケース（周波数誤差大）',
                        data: [
                            { volume: 75, frequency: 300.0, clarity: 0.8, timestamp: Date.now() },
                            { volume: 80, frequency: 310.0, clarity: 0.9, timestamp: Date.now() + 100 }
                        ]
                    },
                    {
                        name: '失敗ケース（音量不足）',
                        data: [
                            { volume: 20, frequency: 261.6, clarity: 0.8, timestamp: Date.now() },
                            { volume: 15, frequency: 260.0, clarity: 0.9, timestamp: Date.now() + 100 }
                        ]
                    }
                ];
                
                const targetNote = { name: 'C4', frequency: 261.6 };
                
                testCases.forEach((testCase, index) => {
                    const result = tester.analyzeMeasurementData('C4', targetNote, testCase.data);
                    
                    logResult('voice-range-tester-results', `${testCase.name}:`, 'info');
                    logResult('voice-range-tester-results', `  成功: ${result.success}`, 'info');
                    logResult('voice-range-tester-results', `  周波数誤差: ${result.frequencyError?.toFixed(2)}%`, 'info');
                    logResult('voice-range-tester-results', `  信頼度: ${result.confidence?.toFixed(1)}%`, 'info');
                    logResult('voice-range-tester-results', `  理由: ${result.reason}`, 'info');
                });
                
                logResult('voice-range-tester-results', '分析機能テスト完了', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `分析機能エラー: ${error.message}`, 'error');
            }
        };

        window.testNoteMapping = function() {
            try {
                logResult('voice-range-tester-results', '音名マッピングテスト開始', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'インスタンスを先に作成してください', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                // 全音名の検索テスト
                const testNotes = ['C3', 'G3', 'C4', 'A4', 'C5', 'X1']; // X1は存在しない音名
                
                testNotes.forEach(noteName => {
                    const note = tester.findNoteByName(noteName);
                    if (note) {
                        logResult('voice-range-tester-results', `${noteName}: ${note.frequency} Hz`, 'info');
                    } else {
                        logResult('voice-range-tester-results', `${noteName}: 見つかりませんでした`, 'warning');
                    }
                });
                
                // 統計情報テスト
                const stats = tester.getStatistics();
                logResult('voice-range-tester-results', `総測定数: ${stats.totalMeasurements}`, 'info');
                
                logResult('voice-range-tester-results', '音名マッピングテスト完了', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `音名マッピングエラー: ${error.message}`, 'error');
            }
        };

        // ===== 統合テスト =====
        window.runAllTests = async function() {
            clearSectionResults('overall-results');
            TestStats.reset();
            const startTime = Date.now();
            
            try {
                logResult('overall-results', '=== 全体テスト開始 ===', 'info');
                document.getElementById('run-all-btn').disabled = true;
                
                // AudioDetectionComponent テストセット
                logResult('overall-results', '🎙️ AudioDetectionComponent テスト群実行中...', 'info');
                await window.testAudioDetectionComponent();
                await new Promise(resolve => setTimeout(resolve, 300));
                await window.testAudioDetectionInit();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testDeviceDetection();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // RecordingController テストセット
                logResult('overall-results', '🎛️ RecordingController テスト群実行中...', 'info');
                window.testRecordingController();
                await new Promise(resolve => setTimeout(resolve, 300));
                await window.testRecordingControllerInit();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // VoiceRangeUI テストセット
                logResult('overall-results', '🎨 VoiceRangeUI テスト群実行中...', 'info');
                window.testVoiceRangeUI();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testUIElements();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // VoiceRangeTesterV113 テストセット
                logResult('overall-results', '🎯 VoiceRangeTesterV113 テスト群実行中...', 'info');
                window.testVoiceRangeTester();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testMeasurement();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testAnalysis();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                logResult('overall-results', '=== 全体テスト完了 ===', 'success');
                logResult('overall-results', `実行時間: ${duration}ms`, 'info');
                logResult('overall-results', `成功: ${TestStats.passed}, 失敗: ${TestStats.failed}, 合計: ${TestStats.total}`, 'info');
                logResult('overall-results', 'コンソールで詳細ログを確認してください', 'info');
                
            } catch (error) {
                logResult('overall-results', `全体テストエラー: ${error.message}`, 'error');
            } finally {
                document.getElementById('run-all-btn').disabled = false;
            }
        };

        window.runCriticalTests = async function() {
            clearSectionResults('overall-results');
            TestStats.reset();
            
            try {
                logResult('overall-results', '⚡ 重要テスト実行開始', 'info');
                
                // 最重要テストのみ実行
                await window.testAudioDetectionComponent();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testRecordingController();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testVoiceRangeUI();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testVoiceRangeTester();
                
                logResult('overall-results', '⚡ 重要テスト完了', 'success');
                logResult('overall-results', `結果: ${TestStats.passed}/${TestStats.total} 成功`, 'info');
                
            } catch (error) {
                logResult('overall-results', `重要テストエラー: ${error.message}`, 'error');
            }
        };

        window.clearResults = function() {
            const sections = [
                'audio-detection-results',
                'recording-controller-results', 
                'voice-range-ui-results',
                'voice-range-tester-results',
                'overall-results'
            ];
            
            sections.forEach(sectionId => clearSectionResults(sectionId));
            window.testInstances = {};
            TestStats.reset();
            console.clear();
            
            logResult('overall-results', 'テスト結果をクリアしました', 'info');
        };

        window.exportResults = function() {
            const timestamp = new Date().toISOString();
            const results = {
                timestamp,
                stats: TestStats,
                testInstances: Object.keys(window.testInstances),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hasTouch: 'ontouchend' in document
            };
            
            const dataStr = JSON.stringify(results, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `voice-range-test-results-${timestamp.slice(0,19).replace(/:/g, '-')}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            logResult('overall-results', 'テスト結果をエクスポートしました', 'success');
        };

        // ===== 初期化 =====
        document.addEventListener('DOMContentLoaded', function() {
            TestStats.reset();
            logResult('overall-results', '🧪 完全スタンドアロン版単体テスト環境準備完了', 'success');
            logResult('overall-results', 'CORSエラーなしで動作します', 'info');
        });

    </script>
</body>
</html>