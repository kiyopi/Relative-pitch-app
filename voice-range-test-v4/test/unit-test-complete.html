<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Unit Test - voice-range-test-v4</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* å®Œå…¨ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ç‰ˆ - CSSã‚‚å†…åŒ… */
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        .test-container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 2rem;
        }
        
        .test-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }
        
        .test-result {
            margin: 0.5rem 0;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-left: 4px solid transparent;
        }
        
        .test-success {
            background: rgba(16, 185, 129, 0.15);
            border-left-color: #10b981;
            color: #34d399;
        }
        
        .test-error {
            background: rgba(239, 68, 68, 0.15);
            border-left-color: #ef4444;
            color: #f87171;
        }
        
        .test-info {
            background: rgba(59, 130, 246, 0.15);
            border-left-color: #3b82f6;
            color: #60a5fa;
        }
        
        .test-warning {
            background: rgba(245, 158, 11, 0.15);
            border-left-color: #f59e0b;
            color: #fbbf24;
        }
        
        .test-button {
            margin: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .test-button:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .test-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .test-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .test-button.success:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            background: linear-gradient(135deg, #60a5fa 0%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 1.5rem 0;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(135deg, #60a5fa 0%, #34d399 100%);
            border-radius: 2px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .cors-notice {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .cors-notice h3 {
            color: #fbbf24;
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .cors-notice p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .mock-ui-elements {
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .stats-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .stats-item .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #60a5fa;
        }
        
        .stats-item .label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.5rem;
        }
        
        @media (max-width: 768px) {
            .test-container {
                margin: 1rem;
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .test-section {
                padding: 1rem;
            }
            
            .button-group {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="test-container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <div class="header">
            <h1>ğŸ§ª voice-range-test-v4</h1>
            <p>å®Œå…¨ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ç‰ˆ å˜ä½“ãƒ†ã‚¹ãƒˆ</p>
        </div>

        <!-- CORSå¯¾å‡¦æƒ…å ± -->
        <div class="cors-notice">
            <h3>ğŸ“‹ å®Œå…¨ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ç‰ˆ</h3>
            <p>
                å…¨ã¦ã®ã‚³ãƒ¼ãƒ‰ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å†…åŒ…ã—ã€å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ä¾å­˜ã‚’å®Œå…¨ã«æ’é™¤ã€‚<br>
                CORSã‚¨ãƒ©ãƒ¼ãªã—ã§ç›´æ¥ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ä½œã™ã‚‹ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã™ã€‚
            </p>
        </div>

        <!-- çµ±è¨ˆæƒ…å ± -->
        <div class="test-section">
            <h2 class="section-title">ğŸ“Š ãƒ†ã‚¹ãƒˆçµ±è¨ˆ</h2>
            <div class="stats-grid" id="stats-grid">
                <div class="stats-item">
                    <div class="value" id="total-tests">0</div>
                    <div class="label">ç·ãƒ†ã‚¹ãƒˆæ•°</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="passed-tests">0</div>
                    <div class="label">æˆåŠŸ</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="failed-tests">0</div>
                    <div class="label">å¤±æ•—</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="test-duration">0ms</div>
                    <div class="label">å®Ÿè¡Œæ™‚é–“</div>
                </div>
            </div>
        </div>

        <!-- ãƒ¢ãƒƒã‚¯ç”¨UIè¦ç´ ï¼ˆéè¡¨ç¤ºï¼‰ -->
        <div class="mock-ui-elements">
            <div id="volume-progress" style="width: 0%;"></div>
            <div id="volume-percentage">0%</div>
            <div id="range-test-volume-bar" style="width: 0%;"></div>
            <div id="range-test-volume-text">0%</div>
            <div id="range-test-frequency-value">-- Hz</div>
            <button id="start-mic-test">ãƒã‚¤ã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹</button>
            <button id="start-range-test">éŸ³åŸŸãƒ†ã‚¹ãƒˆé–‹å§‹</button>
            <div id="recording-status">æº–å‚™ä¸­</div>
            <div id="test-progress">0/15</div>
            <button class="record-btn" data-note="C3">è¨˜éŒ²</button>
            <button class="record-btn" data-note="D3">è¨˜éŒ²</button>
            <button class="record-btn" data-note="E3">è¨˜éŒ²</button>
        </div>

        <!-- AudioDetectionComponent ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="section-title">ğŸ™ï¸ AudioDetectionComponent</h2>
            <div class="button-group">
                <button class="test-button" onclick="testAudioDetectionComponent()">åŸºæœ¬å‹•ä½œ</button>
                <button class="test-button" onclick="testAudioDetectionInit()">åˆæœŸåŒ–</button>
                <button class="test-button" onclick="testAudioDetectionDestroy()">ç ´æ£„å‡¦ç†</button>
                <button class="test-button" onclick="testDeviceDetection()">ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡º</button>
                <button class="test-button" onclick="testCallbacks()">ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯</button>
            </div>
            <div id="audio-detection-results"></div>
        </section>

        <!-- RecordingController ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="section-title">ğŸ›ï¸ RecordingController</h2>
            <div class="button-group">
                <button class="test-button" onclick="testRecordingController()">åŸºæœ¬å‹•ä½œ</button>
                <button class="test-button" onclick="testRecordingControllerInit()">åˆæœŸåŒ–</button>
                <button class="test-button" onclick="testPhaseTransition()">ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»</button>
                <button class="test-button" onclick="testEventHandlers()">ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†</button>
            </div>
            <div id="recording-controller-results"></div>
        </section>

        <!-- VoiceRangeUI ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="section-title">ğŸ¨ VoiceRangeUI</h2>
            <div class="button-group">
                <button class="test-button" onclick="testVoiceRangeUI()">åŸºæœ¬å‹•ä½œ</button>
                <button class="test-button" onclick="testUIElements()">UIè¦ç´ </button>
                <button class="test-button" onclick="testAnimations()">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</button>
                <button class="test-button" onclick="testProgressUpdate()">é€²æ—æ›´æ–°</button>
            </div>
            <div id="voice-range-ui-results"></div>
        </section>

        <!-- VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="section-title">ğŸ¯ VoiceRangeTesterV113</h2>
            <div class="button-group">
                <button class="test-button" onclick="testVoiceRangeTester()">åŸºæœ¬å‹•ä½œ</button>
                <button class="test-button" onclick="testMeasurement()">æ¸¬å®šæ©Ÿèƒ½</button>
                <button class="test-button" onclick="testAnalysis()">åˆ†ææ©Ÿèƒ½</button>
                <button class="test-button" onclick="testNoteMapping()">éŸ³åãƒãƒƒãƒ”ãƒ³ã‚°</button>
            </div>
            <div id="voice-range-tester-results"></div>
        </section>

        <!-- çµ±åˆãƒ†ã‚¹ãƒˆ -->
        <section class="test-section">
            <h2 class="section-title">âš¡ çµ±åˆãƒ†ã‚¹ãƒˆ</h2>
            <div class="button-group">
                <button class="test-button success" onclick="runAllTests()" id="run-all-btn">å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="test-button" onclick="runCriticalTests()">é‡è¦ãƒ†ã‚¹ãƒˆã®ã¿</button>
                <button class="test-button" onclick="clearResults()">çµæœã‚¯ãƒªã‚¢</button>
                <button class="test-button" onclick="exportResults()">çµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            </div>
            <div id="overall-results"></div>
        </section>
    </div>

    <script>
        // ===== ãƒ†ã‚¹ãƒˆçµ±è¨ˆç®¡ç† =====
        const TestStats = {
            total: 0,
            passed: 0,
            failed: 0,
            startTime: null,
            
            reset() {
                this.total = 0;
                this.passed = 0;
                this.failed = 0;
                this.startTime = Date.now();
                this.updateDisplay();
            },
            
            addResult(success) {
                this.total++;
                if (success) {
                    this.passed++;
                } else {
                    this.failed++;
                }
                this.updateDisplay();
            },
            
            updateDisplay() {
                document.getElementById('total-tests').textContent = this.total;
                document.getElementById('passed-tests').textContent = this.passed;
                document.getElementById('failed-tests').textContent = this.failed;
                
                if (this.startTime) {
                    const duration = Date.now() - this.startTime;
                    document.getElementById('test-duration').textContent = `${duration}ms`;
                }
            }
        };

        // ===== AudioDetectionComponent å®Œå…¨å®Ÿè£… =====
        class AudioDetectionComponent {
            constructor(options = {}) {
                this.options = {
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    frequencySelector: '#frequency-value',
                    clarityThreshold: 0.4,
                    minVolumeAbsolute: 0.003,
                    noiseThreshold: 0.1,
                    enableFrequencyDetection: true,
                    enableVolumeDetection: true,
                    updateInterval: 50,
                    autoDetectDevice: true,
                    debugMode: false,
                    logLevel: 'INFO',
                    ...options
                };
                
                this.audioManager = null;
                this.pitchDetector = null;
                this.volumeBar = null;
                this.volumeText = null;
                this.frequencyElement = null;
                this.isInitialized = false;
                this.isDetecting = false;
                this.isDestroyed = false;
                
                this.callbacks = {
                    onVolumeUpdate: null,
                    onPitchUpdate: null,
                    onError: null,
                    onStateChange: null
                };
                
                this.currentData = {
                    volume: 0,
                    frequency: 0,
                    clarity: 0,
                    timestamp: 0
                };
                
                this.deviceSpecs = this.options.autoDetectDevice ? this.detectDevice() : this.getDefaultSpecs();
                this.errorCount = 0;
                this.lastErrorTime = 0;
                this.maxErrors = 5;
                
                this.log('AudioDetectionComponentåˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            detectDevice() {
                const userAgent = navigator.userAgent;
                const isIPhone = /iPhone/.test(userAgent);
                const isIPad = /iPad/.test(userAgent);
                const isIPadOS = /Macintosh/.test(userAgent) && 'ontouchend' in document;
                const hasIOSNavigator = /iPad|iPhone|iPod/.test(userAgent);
                
                if (isIPhone || hasIOSNavigator) {
                    return {
                        type: 'iPhone',
                        sensitivity: 3.5,
                        volumeBarMultiplier: 4.5,
                        noiseReduction: 0.15
                    };
                } else if (isIPad || isIPadOS) {
                    return {
                        type: 'iPad', 
                        sensitivity: 5.0,
                        volumeBarMultiplier: 7.0,
                        noiseReduction: 0.2
                    };
                } else {
                    return {
                        type: 'PC',
                        sensitivity: 2.5,
                        volumeBarMultiplier: 4.0,
                        noiseReduction: 0.1
                    };
                }
            }
            
            getDefaultSpecs() {
                return {
                    type: 'PC',
                    sensitivity: 2.5,
                    volumeBarMultiplier: 4.0,
                    noiseReduction: 0.1
                };
            }
            
            async initialize() {
                if (this.isDestroyed) {
                    throw new Error('ç ´æ£„ã•ã‚ŒãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯å†åˆæœŸåŒ–ã§ãã¾ã›ã‚“');
                }
                
                if (this.isInitialized) {
                    this.log('æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã§ã™', 'WARNING');
                    return true;
                }
                
                try {
                    this.log('åˆæœŸåŒ–é–‹å§‹', 'INFO');
                    this.cacheUIElements();
                    await this.loadPitchProModules();
                    await this.initializeAudioManager();
                    await this.initializePitchDetector();
                    
                    this.isInitialized = true;
                    this.notifyStateChange('initialized');
                    this.log('åˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    return true;
                    
                } catch (error) {
                    this.log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('INITIALIZATION_FAILED', error);
                    throw error;
                }
            }
            
            cacheUIElements() {
                if (this.options.volumeBarSelector) {
                    this.volumeBar = document.querySelector(this.options.volumeBarSelector);
                    if (!this.volumeBar) {
                        this.log(`éŸ³é‡ãƒãƒ¼è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${this.options.volumeBarSelector}`, 'WARNING');
                    }
                }
                
                if (this.options.volumeTextSelector) {
                    this.volumeText = document.querySelector(this.options.volumeTextSelector);
                    if (!this.volumeText) {
                        this.log(`éŸ³é‡ãƒ†ã‚­ã‚¹ãƒˆè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${this.options.volumeTextSelector}`, 'WARNING');
                    }
                }
                
                if (this.options.frequencySelector) {
                    this.frequencyElement = document.querySelector(this.options.frequencySelector);
                    if (!this.frequencyElement) {
                        this.log(`å‘¨æ³¢æ•°è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${this.options.frequencySelector}`, 'WARNING');
                    }
                }
                
                this.log('UIè¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Œäº†', 'INFO');
            }
            
            async loadPitchProModules() {
                try {
                    this.log('PitchProãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ†ã‚¹ãƒˆç‰ˆãƒ¢ãƒƒã‚¯ï¼‰', 'INFO');
                    
                    // é«˜åº¦ãªãƒ¢ãƒƒã‚¯å®Ÿè£…
                    const AudioManager = class {
                        constructor(options) {
                            this.options = options;
                            this.isActive = false;
                        }
                        
                        async initialize() { 
                            await new Promise(resolve => setTimeout(resolve, 100)); // éåŒæœŸå‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                            return true; 
                        }
                        
                        async startCapture() { 
                            this.isActive = true;
                            return true; 
                        }
                        
                        stopCapture() {
                            this.isActive = false;
                        }
                        
                        destroy() {
                            this.stopCapture();
                        }
                        
                        getState() {
                            return { isActive: this.isActive };
                        }
                    };
                    
                    const PitchDetector = class {
                        constructor(options) { 
                            this.options = options; 
                            this.callbacks = {};
                            this.mockInterval = null;
                            this.isDetecting = false;
                        }
                        
                        setCallbacks(callbacks) { 
                            this.callbacks = callbacks; 
                        }
                        
                        async startDetection() { 
                            this.isDetecting = true;
                            // ã‚ˆã‚Šç¾å®Ÿçš„ãªãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
                            this.mockInterval = setInterval(() => {
                                if (this.callbacks.onPitchUpdate && this.isDetecting) {
                                    // éŸ³åŸŸã«å¿œã˜ãŸå‘¨æ³¢æ•°ç”Ÿæˆ
                                    const baseFreq = 200;
                                    const variation = (Math.random() - 0.5) * 50;
                                    const frequency = baseFreq + variation;
                                    
                                    // éŸ³é‡ã®å¤‰å‹•
                                    const baseVolume = 30 + Math.random() * 60;
                                    const volume = Math.max(0, Math.min(100, baseVolume));
                                    
                                    // æ˜ç­åº¦ã®è¨ˆç®—
                                    const clarity = 0.3 + Math.random() * 0.7;
                                    
                                    this.callbacks.onPitchUpdate({
                                        volume,
                                        frequency,
                                        clarity,
                                        timestamp: Date.now()
                                    });
                                }
                            }, 100);
                            return true; 
                        }
                        
                        stopDetection() { 
                            this.isDetecting = false;
                            if (this.mockInterval) {
                                clearInterval(this.mockInterval);
                                this.mockInterval = null;
                            }
                        }
                        
                        destroy() { 
                            this.stopDetection(); 
                        }
                        
                        getState() {
                            return { 
                                isDetecting: this.isDetecting,
                                hasInterval: !!this.mockInterval 
                            };
                        }
                    };
                    
                    this.AudioManager = AudioManager;
                    this.PitchDetector = PitchDetector;
                    this.log('PitchProãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼ˆãƒ†ã‚¹ãƒˆç‰ˆãƒ¢ãƒƒã‚¯ï¼‰', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`PitchProãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async initializeAudioManager() {
                try {
                    this.audioManager = new this.AudioManager({
                        deviceSpecs: this.deviceSpecs,
                        noiseThreshold: this.options.noiseThreshold,
                        debugMode: this.options.debugMode
                    });
                    
                    await this.audioManager.initialize();
                    await this.audioManager.startCapture();
                    this.log('AudioManageråˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`AudioManageråˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async initializePitchDetector() {
                try {
                    this.pitchDetector = new this.PitchDetector({
                        audioManager: this.audioManager,
                        clarityThreshold: this.options.clarityThreshold,
                        minVolumeAbsolute: this.options.minVolumeAbsolute,
                        sensitivity: this.deviceSpecs.sensitivity,
                        debugMode: this.options.debugMode
                    });
                    
                    this.pitchDetector.setCallbacks({
                        onPitchUpdate: (result) => this.handlePitchUpdate(result),
                        onError: (error) => this.handleError('PITCH_DETECTION_ERROR', error)
                    });
                    
                    this.log('PitchDetectoråˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`PitchDetectoråˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async startDetection() {
                if (!this.isInitialized) {
                    throw new Error('åˆæœŸåŒ–ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“');
                }
                
                if (this.isDetecting) {
                    this.log('æ¤œå‡ºã¯æ—¢ã«é–‹å§‹ã•ã‚Œã¦ã„ã¾ã™', 'WARNING');
                    return true;
                }
                
                try {
                    this.log('æ¤œå‡ºé–‹å§‹', 'INFO');
                    await this.pitchDetector.startDetection();
                    this.isDetecting = true;
                    this.notifyStateChange('detecting');
                    this.log('æ¤œå‡ºé–‹å§‹å®Œäº†', 'SUCCESS');
                    return true;
                    
                } catch (error) {
                    this.log(`æ¤œå‡ºé–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('DETECTION_START_FAILED', error);
                    throw error;
                }
            }
            
            stopDetection() {
                if (!this.isDetecting) {
                    this.log('æ¤œå‡ºã¯æ—¢ã«åœæ­¢ã•ã‚Œã¦ã„ã¾ã™', 'WARNING');
                    return;
                }
                
                try {
                    this.log('æ¤œå‡ºåœæ­¢', 'INFO');
                    if (this.pitchDetector) {
                        this.pitchDetector.stopDetection();
                    }
                    this.isDetecting = false;
                    this.notifyStateChange('stopped');
                    this.log('æ¤œå‡ºåœæ­¢å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`æ¤œå‡ºåœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('DETECTION_STOP_FAILED', error);
                }
            }
            
            handlePitchUpdate(result) {
                try {
                    const volume = result.volume;
                    const frequency = result.frequency || 0;
                    const clarity = result.clarity || 0;
                    const timestamp = result.timestamp || Date.now();
                    
                    this.currentData = { volume, frequency, clarity, timestamp };
                    this.updateVolumeDisplay(volume);
                    
                    if (this.options.enableFrequencyDetection && frequency > 0) {
                        this.updateFrequencyDisplay(frequency);
                    }
                    
                    if (this.callbacks.onVolumeUpdate) {
                        this.callbacks.onVolumeUpdate(result);
                    }
                    
                    if (this.callbacks.onPitchUpdate) {
                        this.callbacks.onPitchUpdate(result);
                    }
                    
                } catch (error) {
                    this.log(`éŸ³å£°ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    this.handleError('DATA_UPDATE_FAILED', error);
                }
            }
            
            updateVolumeDisplay(volume) {
                const displayVolume = Math.min(100, volume * this.deviceSpecs.volumeBarMultiplier);
                
                if (this.volumeBar) {
                    this.volumeBar.style.width = `${Math.max(0, displayVolume)}%`;
                }
                
                if (this.volumeText) {
                    this.volumeText.textContent = `${Math.round(displayVolume)}%`;
                }
            }
            
            updateFrequencyDisplay(frequency) {
                if (this.frequencyElement && frequency > 0) {
                    this.frequencyElement.textContent = `${Math.round(frequency)} Hz`;
                }
            }
            
            setCallbacks(callbacks) {
                Object.keys(callbacks).forEach(key => {
                    if (typeof callbacks[key] === 'function' && this.callbacks.hasOwnProperty(key)) {
                        this.callbacks[key] = callbacks[key];
                    }
                });
                this.log('ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®šå®Œäº†', 'INFO');
            }
            
            handleError(type, error) {
                this.errorCount++;
                this.lastErrorTime = Date.now();
                
                const errorInfo = {
                    type,
                    message: error?.message || error,
                    count: this.errorCount,
                    timestamp: this.lastErrorTime,
                    deviceType: this.deviceSpecs.type
                };
                
                this.log(`ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ [${type}]: ${errorInfo.message}`, 'ERROR', errorInfo);
                
                if (this.callbacks.onError) {
                    this.callbacks.onError(errorInfo);
                }
                
                if (this.errorCount >= this.maxErrors) {
                    this.log('æœ€å¤§ã‚¨ãƒ©ãƒ¼æ•°ã«é”ã—ã¾ã—ãŸã€‚æ¤œå‡ºã‚’åœæ­¢ã—ã¾ã™', 'ERROR');
                    this.stopDetection();
                }
            }
            
            notifyStateChange(state) {
                if (this.callbacks.onStateChange) {
                    this.callbacks.onStateChange({
                        state,
                        isInitialized: this.isInitialized,
                        isDetecting: this.isDetecting,
                        timestamp: Date.now()
                    });
                }
            }
            
            getCurrentData() {
                return { ...this.currentData };
            }
            
            getStats() {
                return {
                    errorCount: this.errorCount,
                    lastErrorTime: this.lastErrorTime,
                    deviceType: this.deviceSpecs.type,
                    isInitialized: this.isInitialized,
                    isDetecting: this.isDetecting,
                    isDestroyed: this.isDestroyed,
                    audioManager: this.audioManager?.getState?.() || null,
                    pitchDetector: this.pitchDetector?.getState?.() || null
                };
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[AudioDetectionComponent ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'WARNING':
                        console.warn(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                if (this.isDestroyed) {
                    this.log('æ—¢ã«ç ´æ£„ã•ã‚Œã¦ã„ã¾ã™', 'WARNING');
                    return;
                }
                
                try {
                    this.log('ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„é–‹å§‹', 'INFO');
                    this.stopDetection();
                    
                    if (this.pitchDetector) {
                        this.pitchDetector.destroy();
                        this.pitchDetector = null;
                    }
                    
                    if (this.audioManager) {
                        this.audioManager.destroy();
                        this.audioManager = null;
                    }
                    
                    this.callbacks = {};
                    this.volumeBar = null;
                    this.volumeText = null;
                    this.frequencyElement = null;
                    this.isInitialized = false;
                    this.isDetecting = false;
                    this.isDestroyed = true;
                    
                    this.log('ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„å®Œäº†', 'SUCCESS');
                    
                } catch (error) {
                    this.log(`ãƒªã‚½ãƒ¼ã‚¹ç ´æ£„ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== ç°¡ç•¥ç‰ˆ RecordingController =====
        class RecordingController {
            constructor(options = {}) {
                this.options = { debugMode: false, ...options };
                this.currentPhase = 'initial';
                this.isRecording = false;
                this.recordingData = [];
                this.currentNote = null;
                this.audioDetector = null;
                this.elements = {};
                this.eventListeners = new Map();
                
                this.log('RecordingControlleråˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            async initialize() {
                try {
                    this.log('åˆæœŸåŒ–é–‹å§‹', 'INFO');
                    this.cacheElements();
                    this.setupEventListeners();
                    this.updateUIState('initial');
                    this.log('åˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            cacheElements() {
                const selectors = {
                    micTestButton: '#start-mic-test',
                    rangeTestStartButton: '#start-range-test', 
                    statusDisplay: '#recording-status',
                    progressDisplay: '#test-progress'
                };
                
                Object.keys(selectors).forEach(key => {
                    const element = document.querySelector(selectors[key]);
                    if (element) {
                        this.elements[key] = element;
                    }
                });
                
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
                this.log(`è¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Œäº†: ${Object.keys(this.elements).length}å€‹`, 'INFO');
            }
            
            setupEventListeners() {
                this.log('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š', 'INFO');
                // å®Ÿéš›ã®å®Ÿè£…ã§ã¯å„è¦ç´ ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            }
            
            updateUIState(phase) {
                const previousPhase = this.currentPhase;
                this.currentPhase = phase;
                
                document.body.classList.remove(`phase-${previousPhase}`);
                document.body.classList.add(`phase-${phase}`);
                
                this.log(`ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´: ${previousPhase} â†’ ${phase}`, 'INFO');
            }
            
            async startMicTest() {
                try {
                    this.log('ãƒã‚¤ã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹', 'INFO');
                    this.updateUIState('mic-test');
                    
                    // ãƒ¢ãƒƒã‚¯ã§ã®éåŒæœŸå‡¦ç†
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    this.log('ãƒã‚¤ã‚¯ãƒ†ã‚¹ãƒˆå®Œäº†', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`ãƒã‚¤ã‚¯ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            async startRangeTest() {
                try {
                    this.log('éŸ³åŸŸãƒ†ã‚¹ãƒˆé–‹å§‹', 'INFO');
                    this.updateUIState('range-test');
                    
                    // ãƒ¢ãƒƒã‚¯ã§ã®éåŒæœŸå‡¦ç†
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    this.log('éŸ³åŸŸãƒ†ã‚¹ãƒˆæº–å‚™å®Œäº†', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`éŸ³åŸŸãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[RecordingController ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                try {
                    this.log('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹', 'INFO');
                    this.eventListeners.clear();
                    this.elements = {};
                    this.log('ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†', 'SUCCESS');
                } catch (error) {
                    this.log(`ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== ç°¡ç•¥ç‰ˆ VoiceRangeUI =====
        class VoiceRangeUI {
            constructor(options = {}) {
                this.options = { 
                    enableAnimations: true,
                    totalNotes: 15,
                    debugMode: false, 
                    ...options 
                };
                this.currentPhase = 'initial';
                this.completedNotes = new Set();
                this.elements = {};
                this.animations = {};
                
                this.log('VoiceRangeUIåˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            initialize() {
                try {
                    this.log('UIåˆæœŸåŒ–é–‹å§‹', 'INFO');
                    this.cacheUIElements();
                    this.setPhase('initial');
                    this.updateProgress(0, this.options.totalNotes);
                    this.log('UIåˆæœŸåŒ–å®Œäº†', 'SUCCESS');
                    return true;
                } catch (error) {
                    this.log(`UIåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                    throw error;
                }
            }
            
            cacheUIElements() {
                const selectors = {
                    statusDisplay: '#recording-status',
                    progressDisplay: '#test-progress',
                    micTestButton: '#start-mic-test',
                    rangeStartButton: '#start-range-test'
                };
                
                Object.keys(selectors).forEach(key => {
                    const element = document.querySelector(selectors[key]);
                    if (element) {
                        this.elements[key] = element;
                    }
                });
                
                this.elements.recordButtons = document.querySelectorAll('.record-btn');
                this.log(`UIè¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Œäº†: ${Object.keys(this.elements).length}å€‹`, 'INFO');
            }
            
            setPhase(phase) {
                this.log(`ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´: ${this.currentPhase} â†’ ${phase}`, 'INFO');
                const previousPhase = this.currentPhase;
                this.currentPhase = phase;
                
                const body = document.body;
                body.classList.remove(`phase-${previousPhase}`);
                body.classList.add(`phase-${phase}`);
                
                // ãƒ•ã‚§ãƒ¼ã‚ºå¤‰æ›´ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.options.enableAnimations) {
                    this.playPhaseTransitionAnimation(previousPhase, phase);
                }
            }
            
            playPhaseTransitionAnimation(from, to) {
                this.log(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ: ${from} â†’ ${to}`, 'INFO');
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…ã¯ãƒ¢ãƒƒã‚¯
            }
            
            updateProgress(completed, total = this.options.totalNotes) {
                const percentage = Math.round((completed / total) * 100);
                
                if (this.elements.progressDisplay) {
                    this.elements.progressDisplay.textContent = `é€²æ—: ${completed}/${total}éŸ³åŸŸ (${percentage}%)`;
                }
                
                this.log(`é€²æ—æ›´æ–°: ${completed}/${total} (${percentage}%)`, 'INFO');
                return percentage;
            }
            
            updateStatus(message, type = 'info') {
                if (this.elements.statusDisplay) {
                    this.elements.statusDisplay.textContent = message;
                    this.elements.statusDisplay.className = `status status-${type}`;
                }
                this.log(`ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°: ${message}`, 'INFO');
            }
            
            startRecordingAnimation(noteIndex) {
                this.log(`è¨˜éŒ²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹: Note ${noteIndex}`, 'INFO');
                if (this.elements.recordButtons[noteIndex]) {
                    this.elements.recordButtons[noteIndex].classList.add('recording');
                }
            }
            
            stopRecordingAnimation(noteIndex, success = true) {
                this.log(`è¨˜éŒ²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢: Note ${noteIndex}, æˆåŠŸ: ${success}`, 'INFO');
                if (this.elements.recordButtons[noteIndex]) {
                    const button = this.elements.recordButtons[noteIndex];
                    button.classList.remove('recording');
                    button.classList.add(success ? 'success' : 'failed');
                }
            }
            
            log(message, level = 'INFO', data = null) {
                if (!this.options.debugMode && level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[VoiceRangeUI ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
            
            destroy() {
                try {
                    this.log('UIã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹', 'INFO');
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢
                    Object.keys(this.animations).forEach(key => {
                        if (this.animations[key]) {
                            clearInterval(this.animations[key]);
                        }
                    });
                    
                    this.elements = {};
                    this.log('UIã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†', 'SUCCESS');
                } catch (error) {
                    this.log(`UIã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'ERROR');
                }
            }
        }

        // ===== VoiceRangeTesterV113 å®Ÿè£… =====
        class VoiceRangeTesterV113 {
            constructor(options = {}) {
                this.options = {
                    targetNotes: [
                        { name: 'C3', frequency: 130.8 },
                        { name: 'D3', frequency: 146.8 },
                        { name: 'E3', frequency: 164.8 },
                        { name: 'F3', frequency: 174.6 },
                        { name: 'G3', frequency: 196.0 },
                        { name: 'A3', frequency: 220.0 },
                        { name: 'B3', frequency: 246.9 },
                        { name: 'C4', frequency: 261.6 },
                        { name: 'D4', frequency: 293.7 },
                        { name: 'E4', frequency: 329.6 },
                        { name: 'F4', frequency: 349.2 },
                        { name: 'G4', frequency: 392.0 },
                        { name: 'A4', frequency: 440.0 },
                        { name: 'B4', frequency: 493.9 },
                        { name: 'C5', frequency: 523.3 }
                    ],
                    tolerancePercent: 5.0,
                    minRecordingDuration: 2.0,
                    ...options
                };
                
                this.results = new Map();
                this.audioDetector = null;
                
                this.log('VoiceRangeTesterV113åˆæœŸåŒ–å®Œäº†', 'SUCCESS');
            }
            
            setAudioDetector(audioDetector) {
                this.audioDetector = audioDetector;
                this.log('AudioDetectorè¨­å®šå®Œäº†', 'INFO');
            }
            
            findNoteByName(noteName) {
                return this.options.targetNotes.find(note => note.name === noteName);
            }
            
            async measureRange(noteName, duration = 3000) {
                if (!this.audioDetector) {
                    throw new Error('AudioDetectionComponentãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                }
                
                const targetNote = this.findNoteByName(noteName);
                if (!targetNote) {
                    throw new Error(`æœªå¯¾å¿œã®éŸ³å: ${noteName}`);
                }
                
                const measurementData = [];
                const startTime = Date.now();
                
                return new Promise((resolve) => {
                    const collectData = (result) => {
                        measurementData.push({
                            volume: result.volume,
                            frequency: result.frequency,
                            clarity: result.clarity,
                            timestamp: result.timestamp
                        });
                    };
                    
                    this.audioDetector.setCallbacks({
                        onPitchUpdate: collectData
                    });
                    
                    setTimeout(() => {
                        const result = this.analyzeMeasurementData(noteName, targetNote, measurementData);
                        this.results.set(noteName, result);
                        resolve(result);
                    }, duration);
                });
            }
            
            analyzeMeasurementData(noteName, targetNote, data) {
                if (data.length === 0) {
                    return {
                        noteName,
                        success: false,
                        reason: 'ãƒ‡ãƒ¼ã‚¿ãªã—',
                        confidence: 0,
                        dataCount: 0
                    };
                }
                
                const validData = data.filter(d => d.volume > 30 && d.frequency > 0 && d.clarity > 0.4);
                
                if (validData.length === 0) {
                    return {
                        noteName,
                        success: false,
                        reason: 'æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ãªã—',
                        confidence: 0,
                        dataCount: data.length,
                        validDataCount: 0
                    };
                }
                
                const avgFrequency = validData.reduce((sum, d) => sum + d.frequency, 0) / validData.length;
                const avgVolume = validData.reduce((sum, d) => sum + d.volume, 0) / validData.length;
                const avgClarity = validData.reduce((sum, d) => sum + d.clarity, 0) / validData.length;
                
                const frequencyError = Math.abs(avgFrequency - targetNote.frequency) / targetNote.frequency * 100;
                const isAccurate = frequencyError <= this.options.tolerancePercent;
                
                // ä¿¡é ¼åº¦è¨ˆç®—ã®æ”¹å–„
                const accuracyScore = Math.max(0, 100 - frequencyError * 2);
                const clarityScore = (avgClarity / 1.0) * 100;
                const volumeScore = (Math.min(avgVolume, 100) / 100) * 100;
                const confidence = (accuracyScore * 0.5 + clarityScore * 0.3 + volumeScore * 0.2);
                
                return {
                    noteName,
                    targetFrequency: targetNote.frequency,
                    measuredFrequency: avgFrequency,
                    frequencyError: frequencyError,
                    avgVolume,
                    avgClarity,
                    confidence,
                    success: isAccurate && confidence > 60,
                    reason: isAccurate ? 'æ¸¬å®šæˆåŠŸ' : `å‘¨æ³¢æ•°èª¤å·®: ${frequencyError.toFixed(1)}%`,
                    dataCount: data.length,
                    validDataCount: validData.length,
                    accuracyScore,
                    clarityScore,
                    volumeScore
                };
            }
            
            getResults() {
                return Array.from(this.results.values());
            }
            
            getResultByNote(noteName) {
                return this.results.get(noteName);
            }
            
            clearResults() {
                this.results.clear();
                this.log('æ¸¬å®šçµæœã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'INFO');
            }
            
            getStatistics() {
                const results = this.getResults();
                if (results.length === 0) {
                    return { totalMeasurements: 0 };
                }
                
                const successful = results.filter(r => r.success);
                const avgConfidence = results.reduce((sum, r) => sum + r.confidence, 0) / results.length;
                const avgFrequencyError = results.reduce((sum, r) => sum + r.frequencyError, 0) / results.length;
                
                return {
                    totalMeasurements: results.length,
                    successfulMeasurements: successful.length,
                    successRate: (successful.length / results.length) * 100,
                    avgConfidence,
                    avgFrequencyError,
                    bestResult: results.reduce((best, current) => 
                        current.confidence > best.confidence ? current : best, results[0]),
                    worstResult: results.reduce((worst, current) => 
                        current.confidence < worst.confidence ? current : worst, results[0])
                };
            }
            
            log(message, level = 'INFO', data = null) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[VoiceRangeTesterV113 ${timestamp}] ${level}: ${message}`;
                
                switch (level) {
                    case 'ERROR':
                        console.error(logMessage, data);
                        break;
                    case 'SUCCESS':
                        console.log(`%c${logMessage}`, 'color: #10b981', data);
                        break;
                    default:
                        console.log(logMessage, data);
                }
            }
        }

        // ===== ãƒ†ã‚¹ãƒˆç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° =====
        window.testInstances = {};
        window.testResults = [];

        // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° =====
        function logResult(sectionId, message, type = 'info') {
            const section = document.getElementById(sectionId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result test-${type}`;
            resultDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            section.appendChild(resultDiv);
            
            console.log(`[TEST ${type.toUpperCase()}] ${message}`);
            TestStats.addResult(type === 'success' || type === 'info');
        }

        function clearSectionResults(sectionId) {
            const section = document.getElementById(sectionId);
            section.innerHTML = '';
        }

        // ===== AudioDetectionComponent ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testAudioDetectionComponent = async function() {
            clearSectionResults('audio-detection-results');
            try {
                logResult('audio-detection-results', 'AudioDetectionComponentåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const detector = new AudioDetectionComponent({
                    volumeBarSelector: '#volume-progress',
                    volumeTextSelector: '#volume-percentage',
                    debugMode: true
                });
                
                logResult('audio-detection-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                
                const stats = detector.getStats();
                logResult('audio-detection-results', `ãƒ‡ãƒã‚¤ã‚¹: ${stats.deviceType}`, 'info');
                logResult('audio-detection-results', `åˆæœŸåŒ–çŠ¶æ…‹: ${stats.isInitialized}`, 'info');
                logResult('audio-detection-results', `æ¤œå‡ºçŠ¶æ…‹: ${stats.isDetecting}`, 'info');
                
                window.testInstances.audioDetector = detector;
                logResult('audio-detection-results', 'AudioDetectionComponentåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAudioDetectionInit = async function() {
            try {
                logResult('audio-detection-results', 'åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.audioDetector) {
                    logResult('audio-detection-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                const result = await detector.initialize();
                
                if (result) {
                    logResult('audio-detection-results', 'åˆæœŸåŒ–æˆåŠŸ', 'success');
                    
                    const stats = detector.getStats();
                    logResult('audio-detection-results', `åˆæœŸåŒ–çŠ¶æ…‹: ${stats.isInitialized}`, 'info');
                    
                    // æ¤œå‡ºé–‹å§‹ãƒ†ã‚¹ãƒˆ
                    await detector.startDetection();
                    logResult('audio-detection-results', 'æ¤œå‡ºé–‹å§‹æˆåŠŸ', 'success');
                    
                    // 3ç§’å¾Œã«åœæ­¢
                    setTimeout(() => {
                        detector.stopDetection();
                        logResult('audio-detection-results', 'æ¤œå‡ºåœæ­¢æˆåŠŸ', 'info');
                    }, 3000);
                    
                } else {
                    logResult('audio-detection-results', 'åˆæœŸåŒ–å¤±æ•—', 'error');
                }
                
            } catch (error) {
                logResult('audio-detection-results', `åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAudioDetectionDestroy = function() {
            try {
                logResult('audio-detection-results', 'ç ´æ£„ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.audioDetector) {
                    logResult('audio-detection-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“', 'error');
                    return;
                }
                
                const detector = window.testInstances.audioDetector;
                detector.destroy();
                
                const stats = detector.getStats();
                logResult('audio-detection-results', `ç ´æ£„çŠ¶æ…‹: ${stats.isDestroyed}`, 'success');
                
                // é‡è¤‡ç ´æ£„ãƒ†ã‚¹ãƒˆ
                detector.destroy();
                logResult('audio-detection-results', 'é‡è¤‡ç ´æ£„ãƒ†ã‚¹ãƒˆå®Œäº†ï¼ˆè­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¹ãï¼‰', 'info');
                
            } catch (error) {
                logResult('audio-detection-results', `ç ´æ£„ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testDeviceDetection = function() {
            try {
                logResult('audio-detection-results', 'ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const detector = new AudioDetectionComponent({ debugMode: true });
                const stats = detector.getStats();
                
                logResult('audio-detection-results', `æ¤œå‡ºãƒ‡ãƒã‚¤ã‚¹: ${stats.deviceType}`, 'info');
                logResult('audio-detection-results', `User Agent: ${navigator.userAgent.substring(0, 80)}...`, 'info');
                
                const hasTouch = 'ontouchend' in document;
                logResult('audio-detection-results', `ã‚¿ãƒƒãƒã‚µãƒãƒ¼ãƒˆ: ${hasTouch}`, 'info');
                
                const platform = navigator.platform;
                logResult('audio-detection-results', `ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ : ${platform}`, 'info');
                
                detector.destroy();
                logResult('audio-detection-results', 'ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('audio-detection-results', `ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testCallbacks = async function() {
            try {
                logResult('audio-detection-results', 'ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const detector = new AudioDetectionComponent({ debugMode: true });
                
                let volumeUpdateCount = 0;
                let pitchUpdateCount = 0;
                let stateChangeCount = 0;
                
                detector.setCallbacks({
                    onVolumeUpdate: (result) => {
                        volumeUpdateCount++;
                    },
                    onPitchUpdate: (result) => {
                        pitchUpdateCount++;
                    },
                    onStateChange: (state) => {
                        stateChangeCount++;
                        logResult('audio-detection-results', `çŠ¶æ…‹å¤‰æ›´: ${state.state}`, 'info');
                    }
                });
                
                await detector.initialize();
                await detector.startDetection();
                
                // 2ç§’å¾…æ©Ÿã—ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œå›æ•°ã‚’ãƒã‚§ãƒƒã‚¯
                setTimeout(() => {
                    detector.stopDetection();
                    logResult('audio-detection-results', `éŸ³é‡æ›´æ–°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯: ${volumeUpdateCount}å›`, 'info');
                    logResult('audio-detection-results', `éŸ³ç¨‹æ›´æ–°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯: ${pitchUpdateCount}å›`, 'info');
                    logResult('audio-detection-results', `çŠ¶æ…‹å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯: ${stateChangeCount}å›`, 'info');
                    
                    if (pitchUpdateCount > 0) {
                        logResult('audio-detection-results', 'ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆæˆåŠŸ', 'success');
                    } else {
                        logResult('audio-detection-results', 'ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œå›æ•°ãŒå°‘ãªã™ãã¾ã™', 'warning');
                    }
                    
                    detector.destroy();
                }, 2000);
                
            } catch (error) {
                logResult('audio-detection-results', `ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== RecordingController ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testRecordingController = function() {
            clearSectionResults('recording-controller-results');
            try {
                logResult('recording-controller-results', 'RecordingControlleråŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const controller = new RecordingController({ debugMode: true });
                
                logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                logResult('recording-controller-results', `åˆæœŸãƒ•ã‚§ãƒ¼ã‚º: ${controller.currentPhase}`, 'info');
                logResult('recording-controller-results', `è¨˜éŒ²çŠ¶æ…‹: ${controller.isRecording}`, 'info');
                
                window.testInstances.recordingController = controller;
                logResult('recording-controller-results', 'RecordingControlleråŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testRecordingControllerInit = async function() {
            try {
                logResult('recording-controller-results', 'åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                const result = await controller.initialize();
                
                if (result) {
                    logResult('recording-controller-results', 'åˆæœŸåŒ–æˆåŠŸ', 'success');
                    logResult('recording-controller-results', `UIè¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ•°: ${Object.keys(controller.elements).length}`, 'info');
                    
                    // æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
                    await controller.startMicTest();
                    logResult('recording-controller-results', 'ãƒã‚¤ã‚¯ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                    
                    await controller.startRangeTest();
                    logResult('recording-controller-results', 'éŸ³åŸŸãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                    
                } else {
                    logResult('recording-controller-results', 'åˆæœŸåŒ–å¤±æ•—', 'error');
                }
                
            } catch (error) {
                logResult('recording-controller-results', `åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testPhaseTransition = function() {
            try {
                logResult('recording-controller-results', 'ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                
                const phases = ['initial', 'mic-test', 'range-test', 'completed'];
                phases.forEach((phase, index) => {
                    setTimeout(() => {
                        controller.updateUIState(phase);
                        logResult('recording-controller-results', `${phase}ãƒ•ã‚§ãƒ¼ã‚º: ${controller.currentPhase}`, 'info');
                        
                        if (index === phases.length - 1) {
                            logResult('recording-controller-results', 'ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                        }
                    }, index * 500);
                });
                
            } catch (error) {
                logResult('recording-controller-results', `ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testEventHandlers = function() {
            try {
                logResult('recording-controller-results', 'ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.recordingController) {
                    logResult('recording-controller-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const controller = window.testInstances.recordingController;
                const listenerCount = controller.eventListeners.size;
                logResult('recording-controller-results', `ç™»éŒ²ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼æ•°: ${listenerCount}`, 'info');
                
                // è¦ç´ ã®å­˜åœ¨ç¢ºèª
                const elementCount = Object.keys(controller.elements).length;
                logResult('recording-controller-results', `ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¦ç´ æ•°: ${elementCount}`, 'info');
                
                logResult('recording-controller-results', 'ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('recording-controller-results', `ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeUI ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testVoiceRangeUI = function() {
            clearSectionResults('voice-range-ui-results');
            try {
                logResult('voice-range-ui-results', 'VoiceRangeUIåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const ui = new VoiceRangeUI({
                    enableAnimations: false,
                    debugMode: true
                });
                
                logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                logResult('voice-range-ui-results', `åˆæœŸãƒ•ã‚§ãƒ¼ã‚º: ${ui.currentPhase}`, 'info');
                logResult('voice-range-ui-results', `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š: ${ui.options.enableAnimations}`, 'info');
                
                window.testInstances.voiceRangeUI = ui;
                logResult('voice-range-ui-results', 'VoiceRangeUIåŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-ui-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testUIElements = function() {
            try {
                logResult('voice-range-ui-results', 'UIè¦ç´ ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                const result = ui.initialize();
                
                if (result) {
                    logResult('voice-range-ui-results', 'UIåˆæœŸåŒ–æˆåŠŸ', 'success');
                    logResult('voice-range-ui-results', `ã‚­ãƒ£ãƒƒã‚·ãƒ¥UIè¦ç´ æ•°: ${Object.keys(ui.elements).length}`, 'info');
                    
                    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãƒ†ã‚¹ãƒˆ
                    ui.updateStatus('ãƒ†ã‚¹ãƒˆä¸­...', 'info');
                    logResult('voice-range-ui-results', 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                    
                } else {
                    logResult('voice-range-ui-results', 'UIåˆæœŸåŒ–å¤±æ•—', 'error');
                }
                
            } catch (error) {
                logResult('voice-range-ui-results', `UIè¦ç´ ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAnimations = function() {
            try {
                logResult('voice-range-ui-results', 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                
                const phases = ['mic-test', 'range-test', 'completed'];
                phases.forEach((phase, index) => {
                    setTimeout(() => {
                        ui.setPhase(phase);
                        logResult('voice-range-ui-results', `${phase}ãƒ•ã‚§ãƒ¼ã‚ºè¨­å®šå®Œäº†`, 'info');
                        
                        if (index === phases.length - 1) {
                            logResult('voice-range-ui-results', 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                        }
                    }, index * 300);
                });
                
                // è¨˜éŒ²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
                setTimeout(() => {
                    ui.startRecordingAnimation(0);
                    logResult('voice-range-ui-results', 'è¨˜éŒ²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹', 'info');
                    
                    setTimeout(() => {
                        ui.stopRecordingAnimation(0, true);
                        logResult('voice-range-ui-results', 'è¨˜éŒ²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢ï¼ˆæˆåŠŸï¼‰', 'success');
                    }, 1000);
                }, 1000);
                
            } catch (error) {
                logResult('voice-range-ui-results', `ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testProgressUpdate = function() {
            try {
                logResult('voice-range-ui-results', 'é€²æ—æ›´æ–°ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeUI) {
                    logResult('voice-range-ui-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const ui = window.testInstances.voiceRangeUI;
                
                const progressSteps = [
                    { completed: 0, total: 15 },
                    { completed: 5, total: 15 },
                    { completed: 10, total: 15 },
                    { completed: 15, total: 15 }
                ];
                
                progressSteps.forEach((step, index) => {
                    setTimeout(() => {
                        const percentage = ui.updateProgress(step.completed, step.total);
                        logResult('voice-range-ui-results', `é€²æ—æ›´æ–° ${step.completed}/${step.total} (${percentage}%) å®Œäº†`, 'info');
                        
                        if (index === progressSteps.length - 1) {
                            logResult('voice-range-ui-results', 'é€²æ—æ›´æ–°ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                        }
                    }, index * 200);
                });
                
            } catch (error) {
                logResult('voice-range-ui-results', `é€²æ—æ›´æ–°ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ =====
        window.testVoiceRangeTester = function() {
            clearSectionResults('voice-range-tester-results');
            try {
                logResult('voice-range-tester-results', 'VoiceRangeTesterV113åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const tester = new VoiceRangeTesterV113();
                
                logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ', 'success');
                logResult('voice-range-tester-results', `å¯¾è±¡éŸ³æ•°: ${tester.options.targetNotes.length}`, 'info');
                logResult('voice-range-tester-results', `è¨±å®¹èª¤å·®: ${tester.options.tolerancePercent}%`, 'info');
                
                window.testInstances.voiceRangeTester = tester;
                logResult('voice-range-tester-results', 'VoiceRangeTesterV113åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testMeasurement = function() {
            try {
                logResult('voice-range-tester-results', 'æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                // ãƒ¢ãƒƒã‚¯ AudioDetectionComponentä½œæˆ
                const mockDetector = {
                    setCallbacks: (callbacks) => {
                        logResult('voice-range-tester-results', 'ãƒ¢ãƒƒã‚¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®šå®Œäº†', 'info');
                        
                        // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã§æ¸¬å®šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        setTimeout(() => {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    callbacks.onPitchUpdate({
                                        volume: 75 + Math.random() * 20,
                                        frequency: 261.6 + (Math.random() - 0.5) * 10, // C4å‘¨è¾º
                                        clarity: 0.8 + Math.random() * 0.2,
                                        timestamp: Date.now()
                                    });
                                }, i * 100);
                            }
                        }, 100);
                    }
                };
                
                tester.setAudioDetector(mockDetector);
                logResult('voice-range-tester-results', 'ãƒ¢ãƒƒã‚¯AudioDetectorè¨­å®šå®Œäº†', 'info');
                logResult('voice-range-tester-results', 'æ¸¬å®šæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `æ¸¬å®šæ©Ÿèƒ½ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testAnalysis = function() {
            try {
                logResult('voice-range-tester-results', 'åˆ†ææ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                // è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ¢ãƒƒã‚¯æ¸¬å®šãƒ‡ãƒ¼ã‚¿ã§ãƒ†ã‚¹ãƒˆ
                const testCases = [
                    {
                        name: 'æˆåŠŸã‚±ãƒ¼ã‚¹',
                        data: [
                            { volume: 75, frequency: 261.6, clarity: 0.8, timestamp: Date.now() },
                            { volume: 80, frequency: 260.0, clarity: 0.9, timestamp: Date.now() + 100 },
                            { volume: 85, frequency: 263.0, clarity: 0.7, timestamp: Date.now() + 200 }
                        ]
                    },
                    {
                        name: 'å¤±æ•—ã‚±ãƒ¼ã‚¹ï¼ˆå‘¨æ³¢æ•°èª¤å·®å¤§ï¼‰',
                        data: [
                            { volume: 75, frequency: 300.0, clarity: 0.8, timestamp: Date.now() },
                            { volume: 80, frequency: 310.0, clarity: 0.9, timestamp: Date.now() + 100 }
                        ]
                    },
                    {
                        name: 'å¤±æ•—ã‚±ãƒ¼ã‚¹ï¼ˆéŸ³é‡ä¸è¶³ï¼‰',
                        data: [
                            { volume: 20, frequency: 261.6, clarity: 0.8, timestamp: Date.now() },
                            { volume: 15, frequency: 260.0, clarity: 0.9, timestamp: Date.now() + 100 }
                        ]
                    }
                ];
                
                const targetNote = { name: 'C4', frequency: 261.6 };
                
                testCases.forEach((testCase, index) => {
                    const result = tester.analyzeMeasurementData('C4', targetNote, testCase.data);
                    
                    logResult('voice-range-tester-results', `${testCase.name}:`, 'info');
                    logResult('voice-range-tester-results', `  æˆåŠŸ: ${result.success}`, 'info');
                    logResult('voice-range-tester-results', `  å‘¨æ³¢æ•°èª¤å·®: ${result.frequencyError?.toFixed(2)}%`, 'info');
                    logResult('voice-range-tester-results', `  ä¿¡é ¼åº¦: ${result.confidence?.toFixed(1)}%`, 'info');
                    logResult('voice-range-tester-results', `  ç†ç”±: ${result.reason}`, 'info');
                });
                
                logResult('voice-range-tester-results', 'åˆ†ææ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `åˆ†ææ©Ÿèƒ½ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.testNoteMapping = function() {
            try {
                logResult('voice-range-tester-results', 'éŸ³åãƒãƒƒãƒ”ãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                if (!window.testInstances.voiceRangeTester) {
                    logResult('voice-range-tester-results', 'ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…ˆã«ä½œæˆã—ã¦ãã ã•ã„', 'error');
                    return;
                }
                
                const tester = window.testInstances.voiceRangeTester;
                
                // å…¨éŸ³åã®æ¤œç´¢ãƒ†ã‚¹ãƒˆ
                const testNotes = ['C3', 'G3', 'C4', 'A4', 'C5', 'X1']; // X1ã¯å­˜åœ¨ã—ãªã„éŸ³å
                
                testNotes.forEach(noteName => {
                    const note = tester.findNoteByName(noteName);
                    if (note) {
                        logResult('voice-range-tester-results', `${noteName}: ${note.frequency} Hz`, 'info');
                    } else {
                        logResult('voice-range-tester-results', `${noteName}: è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`, 'warning');
                    }
                });
                
                // çµ±è¨ˆæƒ…å ±ãƒ†ã‚¹ãƒˆ
                const stats = tester.getStatistics();
                logResult('voice-range-tester-results', `ç·æ¸¬å®šæ•°: ${stats.totalMeasurements}`, 'info');
                
                logResult('voice-range-tester-results', 'éŸ³åãƒãƒƒãƒ”ãƒ³ã‚°ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                logResult('voice-range-tester-results', `éŸ³åãƒãƒƒãƒ”ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        // ===== çµ±åˆãƒ†ã‚¹ãƒˆ =====
        window.runAllTests = async function() {
            clearSectionResults('overall-results');
            TestStats.reset();
            const startTime = Date.now();
            
            try {
                logResult('overall-results', '=== å…¨ä½“ãƒ†ã‚¹ãƒˆé–‹å§‹ ===', 'info');
                document.getElementById('run-all-btn').disabled = true;
                
                // AudioDetectionComponent ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆ
                logResult('overall-results', 'ğŸ™ï¸ AudioDetectionComponent ãƒ†ã‚¹ãƒˆç¾¤å®Ÿè¡Œä¸­...', 'info');
                await window.testAudioDetectionComponent();
                await new Promise(resolve => setTimeout(resolve, 300));
                await window.testAudioDetectionInit();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testDeviceDetection();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // RecordingController ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆ
                logResult('overall-results', 'ğŸ›ï¸ RecordingController ãƒ†ã‚¹ãƒˆç¾¤å®Ÿè¡Œä¸­...', 'info');
                window.testRecordingController();
                await new Promise(resolve => setTimeout(resolve, 300));
                await window.testRecordingControllerInit();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // VoiceRangeUI ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆ
                logResult('overall-results', 'ğŸ¨ VoiceRangeUI ãƒ†ã‚¹ãƒˆç¾¤å®Ÿè¡Œä¸­...', 'info');
                window.testVoiceRangeUI();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testUIElements();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆ
                logResult('overall-results', 'ğŸ¯ VoiceRangeTesterV113 ãƒ†ã‚¹ãƒˆç¾¤å®Ÿè¡Œä¸­...', 'info');
                window.testVoiceRangeTester();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testMeasurement();
                await new Promise(resolve => setTimeout(resolve, 300));
                window.testAnalysis();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const endTime = Date.now();
                const duration = endTime - startTime;
                
                logResult('overall-results', '=== å…¨ä½“ãƒ†ã‚¹ãƒˆå®Œäº† ===', 'success');
                logResult('overall-results', `å®Ÿè¡Œæ™‚é–“: ${duration}ms`, 'info');
                logResult('overall-results', `æˆåŠŸ: ${TestStats.passed}, å¤±æ•—: ${TestStats.failed}, åˆè¨ˆ: ${TestStats.total}`, 'info');
                logResult('overall-results', 'ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§è©³ç´°ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„', 'info');
                
            } catch (error) {
                logResult('overall-results', `å…¨ä½“ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            } finally {
                document.getElementById('run-all-btn').disabled = false;
            }
        };

        window.runCriticalTests = async function() {
            clearSectionResults('overall-results');
            TestStats.reset();
            
            try {
                logResult('overall-results', 'âš¡ é‡è¦ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹', 'info');
                
                // æœ€é‡è¦ãƒ†ã‚¹ãƒˆã®ã¿å®Ÿè¡Œ
                await window.testAudioDetectionComponent();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testRecordingController();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testVoiceRangeUI();
                await new Promise(resolve => setTimeout(resolve, 200));
                window.testVoiceRangeTester();
                
                logResult('overall-results', 'âš¡ é‡è¦ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                logResult('overall-results', `çµæœ: ${TestStats.passed}/${TestStats.total} æˆåŠŸ`, 'info');
                
            } catch (error) {
                logResult('overall-results', `é‡è¦ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        };

        window.clearResults = function() {
            const sections = [
                'audio-detection-results',
                'recording-controller-results', 
                'voice-range-ui-results',
                'voice-range-tester-results',
                'overall-results'
            ];
            
            sections.forEach(sectionId => clearSectionResults(sectionId));
            window.testInstances = {};
            TestStats.reset();
            console.clear();
            
            logResult('overall-results', 'ãƒ†ã‚¹ãƒˆçµæœã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        };

        window.exportResults = function() {
            const timestamp = new Date().toISOString();
            const results = {
                timestamp,
                stats: TestStats,
                testInstances: Object.keys(window.testInstances),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hasTouch: 'ontouchend' in document
            };
            
            const dataStr = JSON.stringify(results, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `voice-range-test-results-${timestamp.slice(0,19).replace(/:/g, '-')}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            logResult('overall-results', 'ãƒ†ã‚¹ãƒˆçµæœã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
        };

        // ===== åˆæœŸåŒ– =====
        document.addEventListener('DOMContentLoaded', function() {
            TestStats.reset();
            logResult('overall-results', 'ğŸ§ª å®Œå…¨ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ç‰ˆå˜ä½“ãƒ†ã‚¹ãƒˆç’°å¢ƒæº–å‚™å®Œäº†', 'success');
            logResult('overall-results', 'CORSã‚¨ãƒ©ãƒ¼ãªã—ã§å‹•ä½œã—ã¾ã™', 'info');
        });

    </script>
</body>
</html>