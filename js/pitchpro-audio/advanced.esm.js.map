{"version":3,"file":"advanced.esm.js","sources":["../src/advanced/HarmonicCorrection.ts","../src/types/index.ts","../src/advanced/VoiceAnalyzer.ts","../src/advanced/CalibrationSystem.ts"],"sourcesContent":["/**\n * HarmonicCorrection - Advanced harmonic detection and correction\n * \n * Provides sophisticated harmonic analysis and correction algorithms\n * Handles complex harmonic patterns, subharmonics, and frequency drift\n */\n\nimport type { HarmonicCorrectionResult } from '../types';\n\nexport class HarmonicCorrection {\n  private historyBuffer: Array<{\n    frequency: number;\n    confidence: number;\n    timestamp: number;\n    volume: number;\n  }> = [];\n  \n  private config = {\n    historyWindowMs: 2000,\n    minConfidenceThreshold: 0.6,\n    harmonicToleranceCents: 30,\n    maxHarmonicNumber: 8,\n    stabilityWeight: 0.7,\n    volumeWeight: 0.3\n  };\n\n  constructor(config: Partial<typeof HarmonicCorrection.prototype.config> = {}) {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Apply harmonic correction to detected frequency\n   */\n  correctFrequency(frequency: number, volume: number = 1.0): HarmonicCorrectionResult {\n    const now = Date.now();\n    \n    // Clean old history\n    this.cleanHistory(now);\n    \n    // Add current detection to history\n    this.addToHistory(frequency, volume, now);\n    \n    // Analyze for harmonic patterns\n    const analysis = this.analyzeHarmonics(frequency);\n    \n    // Apply correction if confidence is high enough\n    if (analysis.confidence >= this.config.minConfidenceThreshold) {\n      return {\n        correctedFreq: analysis.correctedFrequency,\n        confidence: analysis.confidence,\n        correctionApplied: Math.abs(analysis.correctedFrequency - frequency) > 1.0\n      };\n    }\n    \n    return {\n      correctedFreq: frequency,\n      confidence: analysis.confidence,\n      correctionApplied: false\n    };\n  }\n\n  /**\n   * Analyze frequency for harmonic patterns\n   */\n  private analyzeHarmonics(frequency: number): {\n    correctedFrequency: number;\n    confidence: number;\n    harmonicNumber?: number;\n    fundamentalCandidate?: number;\n  } {\n    if (this.historyBuffer.length < 3) {\n      return {\n        correctedFrequency: frequency,\n        confidence: 0.1\n      };\n    }\n\n    // Get recent stable frequencies\n    const recentFrequencies = this.historyBuffer\n      .slice(-10)\n      .map(entry => entry.frequency);\n\n    // Look for fundamental candidates\n    const fundamentalCandidates = this.findFundamentalCandidates(frequency);\n    \n    let bestCandidate = {\n      frequency,\n      confidence: 0.1,\n      harmonicNumber: 1\n    };\n\n    // Test each fundamental candidate\n    for (const candidate of fundamentalCandidates) {\n      const confidence = this.calculateHarmonicConfidence(\n        candidate.fundamental,\n        candidate.harmonicNumber,\n        recentFrequencies\n      );\n      \n      if (confidence > bestCandidate.confidence) {\n        bestCandidate = {\n          frequency: candidate.fundamental,\n          confidence,\n          harmonicNumber: candidate.harmonicNumber\n        };\n      }\n    }\n\n    // If we found a likely harmonic, correct to fundamental\n    if (bestCandidate.harmonicNumber > 1 && bestCandidate.confidence > this.config.minConfidenceThreshold) {\n      return {\n        correctedFrequency: bestCandidate.frequency,\n        confidence: bestCandidate.confidence,\n        harmonicNumber: bestCandidate.harmonicNumber,\n        fundamentalCandidate: bestCandidate.frequency\n      };\n    }\n\n    return {\n      correctedFrequency: frequency,\n      confidence: bestCandidate.confidence\n    };\n  }\n\n  /**\n   * Find potential fundamental frequencies for a given detected frequency\n   */\n  private findFundamentalCandidates(frequency: number): Array<{\n    fundamental: number;\n    harmonicNumber: number;\n    likelihood: number;\n  }> {\n    const candidates: Array<{\n      fundamental: number;\n      harmonicNumber: number;\n      likelihood: number;\n    }> = [];\n\n    // Check if this could be a harmonic of a lower fundamental\n    for (let harmonicNum = 2; harmonicNum <= this.config.maxHarmonicNumber; harmonicNum++) {\n      const fundamental = frequency / harmonicNum;\n      \n      // Skip if fundamental is too low for human voice\n      if (fundamental < 60) continue;\n      \n      // Calculate likelihood based on how close it is to exact harmonic ratio\n      const exactHarmonic = fundamental * harmonicNum;\n      const centDeviation = Math.abs(1200 * Math.log2(frequency / exactHarmonic));\n      \n      if (centDeviation <= this.config.harmonicToleranceCents) {\n        const likelihood = 1.0 - (centDeviation / this.config.harmonicToleranceCents);\n        candidates.push({\n          fundamental,\n          harmonicNumber: harmonicNum,\n          likelihood\n        });\n      }\n    }\n\n    // Also consider the frequency itself as fundamental (no correction)\n    candidates.push({\n      fundamental: frequency,\n      harmonicNumber: 1,\n      likelihood: 0.5\n    });\n\n    return candidates.sort((a, b) => b.likelihood - a.likelihood);\n  }\n\n  /**\n   * Calculate confidence that a frequency pattern represents a harmonic series\n   */\n  private calculateHarmonicConfidence(\n    fundamental: number,\n    _harmonicNumber: number,\n    recentFrequencies: number[]\n  ): number {\n    if (recentFrequencies.length < 3) return 0.1;\n\n    let totalConfidence = 0;\n    let validMeasurements = 0;\n\n    // Check how well recent frequencies fit the harmonic pattern\n    for (const freq of recentFrequencies) {\n      // Find the closest harmonic to this frequency\n      let closestHarmonicNum = Math.round(freq / fundamental);\n      if (closestHarmonicNum < 1) closestHarmonicNum = 1;\n      \n      const expectedFreq = fundamental * closestHarmonicNum;\n      const centDeviation = Math.abs(1200 * Math.log2(freq / expectedFreq));\n      \n      if (centDeviation <= this.config.harmonicToleranceCents * 2) {\n        const confidence = 1.0 - (centDeviation / (this.config.harmonicToleranceCents * 2));\n        totalConfidence += confidence;\n        validMeasurements++;\n      }\n    }\n\n    if (validMeasurements === 0) return 0.1;\n\n    // Average confidence, weighted by stability\n    const avgConfidence = totalConfidence / validMeasurements;\n    \n    // Add stability bonus if we have consistent measurements\n    const stabilityBonus = Math.min(validMeasurements / recentFrequencies.length, 1.0);\n    \n    return Math.min(avgConfidence * this.config.stabilityWeight + stabilityBonus * (1 - this.config.stabilityWeight), 1.0);\n  }\n\n  /**\n   * Add frequency detection to history\n   */\n  private addToHistory(frequency: number, volume: number, timestamp: number): void {\n    // Calculate confidence based on volume and stability\n    const volumeConfidence = Math.min(volume, 1.0);\n    let stabilityConfidence = 0.5;\n    \n    if (this.historyBuffer.length > 0) {\n      const lastFreq = this.historyBuffer[this.historyBuffer.length - 1].frequency;\n      const freqRatio = Math.max(frequency, lastFreq) / Math.min(frequency, lastFreq);\n      stabilityConfidence = Math.max(0, 1.0 - (freqRatio - 1.0) * 5); // Penalty for large jumps\n    }\n    \n    const confidence = volumeConfidence * this.config.volumeWeight + \n                      stabilityConfidence * (1 - this.config.volumeWeight);\n    \n    this.historyBuffer.push({\n      frequency,\n      confidence,\n      timestamp,\n      volume\n    });\n    \n    // Limit buffer size\n    if (this.historyBuffer.length > 50) {\n      this.historyBuffer.shift();\n    }\n  }\n\n  /**\n   * Clean old entries from history\n   */\n  private cleanHistory(currentTime: number): void {\n    const cutoffTime = currentTime - this.config.historyWindowMs;\n    this.historyBuffer = this.historyBuffer.filter(entry => entry.timestamp > cutoffTime);\n  }\n\n  /**\n   * Reset correction history\n   */\n  resetHistory(): void {\n    this.historyBuffer = [];\n  }\n\n  /**\n   * Get current analysis statistics\n   */\n  getAnalysisStats(): {\n    historyLength: number;\n    averageConfidence: number;\n    frequencyRange: { min: number; max: number } | null;\n    stabilityScore: number;\n  } {\n    if (this.historyBuffer.length === 0) {\n      return {\n        historyLength: 0,\n        averageConfidence: 0,\n        frequencyRange: null,\n        stabilityScore: 0\n      };\n    }\n\n    const frequencies = this.historyBuffer.map(entry => entry.frequency);\n    const confidences = this.historyBuffer.map(entry => entry.confidence);\n    \n    const avgConfidence = confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length;\n    const minFreq = Math.min(...frequencies);\n    const maxFreq = Math.max(...frequencies);\n    \n    // Calculate stability as inverse of coefficient of variation\n    const mean = frequencies.reduce((sum, freq) => sum + freq, 0) / frequencies.length;\n    const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) / frequencies.length;\n    const coefficientOfVariation = Math.sqrt(variance) / mean;\n    const stabilityScore = Math.max(0, 1.0 - coefficientOfVariation);\n\n    return {\n      historyLength: this.historyBuffer.length,\n      averageConfidence: avgConfidence,\n      frequencyRange: { min: minFreq, max: maxFreq },\n      stabilityScore\n    };\n  }\n\n  /**\n   * Configure correction parameters\n   */\n  updateConfig(newConfig: Partial<typeof this.config>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}","/**\n * TypeScript type definitions for PitchPro Audio Processing\n */\n\n// AudioManager types\nexport interface AudioManagerConfig {\n  sampleRate?: number;\n  channelCount?: number;\n  echoCancellation?: boolean;\n  noiseSuppression?: boolean;\n  autoGainControl?: boolean;\n  latency?: number;\n}\n\n// PitchDetector types\nexport interface PitchDetectorConfig {\n  fftSize?: number;\n  smoothing?: number;\n  clarityThreshold?: number;\n  minVolumeAbsolute?: number;\n}\n\nexport interface PitchDetectionResult {\n  frequency: number;\n  note: string;\n  clarity: number;\n  volume: number;\n  cents?: number;\n}\n\n// NoiseFilter types\nexport interface NoiseFilterConfig {\n  highpassFreq?: number;\n  lowpassFreq?: number;\n  notchFreq?: number;\n  highpassQ?: number;\n  lowpassQ?: number;\n  notchQ?: number;\n  useFilters?: boolean;\n}\n\n// HarmonicCorrection types\nexport interface HarmonicCorrectionResult {\n  correctedFreq: number;\n  confidence: number;\n  correctionApplied: boolean;\n}\n\n// ErrorNotification types\nexport interface NotificationConfig {\n  type: 'error' | 'warning' | 'success' | 'info';\n  title: string;\n  message: string;\n  details?: string[];\n  solution?: string;\n  autoHide?: boolean;\n  duration?: number;\n  priority?: 'low' | 'medium' | 'high';\n}\n\nexport interface NotificationElement extends HTMLElement {\n  'data-notification-id': string;\n}\n\n// Music theory types\nexport interface MusicalNote {\n  name: string;\n  octave: number;\n  midi: number;\n  frequency: number;\n}\n\nexport interface MusicalInterval {\n  name: string;\n  semitones: number;\n  cents: number;\n  ratio: number;\n}\n\n// Voice analysis types\nexport interface VoiceAnalysis {\n  quality: VoiceQuality;\n  stability: number;\n  recommendations: string[];\n}\n\nexport const VoiceQuality = {\n  EXCELLENT: 'excellent' as const,\n  GOOD: 'good' as const,\n  FAIR: 'fair' as const,\n  POOR: 'poor' as const\n};\n\nexport type VoiceQuality = typeof VoiceQuality[keyof typeof VoiceQuality];\n\nexport const AccuracyLevel = {\n  PERFECT: 'perfect' as const,\n  EXCELLENT: 'excellent' as const,\n  GOOD: 'good' as const,\n  FAIR: 'fair' as const,\n  POOR: 'poor' as const\n};\n\nexport type AccuracyLevel = typeof AccuracyLevel[keyof typeof AccuracyLevel];\n\nexport interface AccuracyResult {\n  accuracy: AccuracyLevel;\n  centsOff: number;\n  score: number;\n}\n\n// Device detection types\nexport interface DeviceSpecs {\n  deviceType: 'iPhone' | 'iPad' | 'PC';\n  isIOS: boolean;\n  sensitivity: number;\n  noiseGate: number;\n  divisor: number;\n  gainCompensation: number;\n  noiseThreshold: number;\n  smoothingFactor: number;\n}\n\n// Lifecycle management types\nexport interface MediaStreamResources {\n  audioContext: AudioContext;\n  mediaStream: MediaStream;\n  sourceNode: MediaStreamAudioSourceNode;\n}\n\nexport interface HealthStatus {\n  mediaStreamActive: boolean;\n  audioContextState: string;\n  trackStates: TrackState[];\n  healthy: boolean;\n  refCount?: number;\n}\n\nexport interface TrackState {\n  kind: string;\n  enabled: boolean;\n  readyState: MediaStreamTrackState;\n  muted: boolean;\n}\n\n// Event types\nexport interface MicrophoneControllerEvents {\n  'pitchpro:microphoneGranted': CustomEvent<{ stream: MediaStream }>;\n  'pitchpro:microphoneDenied': CustomEvent<{ error: Error }>;\n  'pitchpro:microphoneStopped': CustomEvent;\n  'pitchpro:sensitivityChanged': CustomEvent<{ sensitivity: number }>;\n  'pitchpro:noiseGateChanged': CustomEvent<{ threshold: number }>;\n  'pitchpro:deviceDetected': CustomEvent<{ specs: DeviceSpecs }>;\n}\n\nexport interface LifecycleEvents {\n  'pitchpro:lifecycle:trackEnded': CustomEvent<{ track: MediaStreamTrack }>;\n  'pitchpro:lifecycle:trackMuted': CustomEvent<{ track: MediaStreamTrack }>;\n  'pitchpro:lifecycle:trackUnmuted': CustomEvent<{ track: MediaStreamTrack }>;\n  'pitchpro:lifecycle:autoRecoverySuccess': CustomEvent;\n  'pitchpro:lifecycle:autoRecoveryFailed': CustomEvent<{ error: Error }>;\n}\n\n// Callback types\nexport type PitchCallback = (result: PitchDetectionResult) => void;\nexport type ErrorCallback = (error: Error) => void;\nexport type StateChangeCallback = (state: string) => void;","/**\n * VoiceAnalyzer - Advanced voice quality and analysis\n * \n * Analyzes voice characteristics, stability, and provides recommendations\n * Includes vibrato detection, breathiness analysis, and vocal health indicators\n */\n\nimport type { VoiceAnalysis } from '../types';\nimport { VoiceQuality } from '../types';\n\nexport class VoiceAnalyzer {\n  private analysisBuffer: Array<{\n    frequency: number;\n    volume: number;\n    clarity: number;\n    timestamp: number;\n  }> = [];\n  \n  private config = {\n    analysisWindowMs: 3000,\n    stabilityThresholdCents: 20,\n    vibratoMinRate: 4.5,\n    vibratoMaxRate: 7.5,\n    vibratoMinDepthCents: 50,\n    breathinessThreshold: 0.3,\n    minAnalysisTime: 1000\n  };\n\n  constructor(config: Partial<typeof VoiceAnalyzer.prototype.config> = {}) {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Analyze voice characteristics from audio data\n   */\n  analyzeVoice(\n    frequency: number, \n    volume: number, \n    clarity: number,\n    spectralData?: Float32Array\n  ): VoiceAnalysis {\n    const timestamp = Date.now();\n    \n    // Add to analysis buffer\n    this.addToBuffer(frequency, volume, clarity, timestamp);\n    \n    // Clean old data\n    this.cleanBuffer(timestamp);\n    \n    // Perform comprehensive analysis\n    const stability = this.calculateStability();\n    const vibrato = this.detectVibrato();\n    const breathiness = spectralData ? this.analyzeBreathiness(spectralData) : null;\n    const consistency = this.analyzeConsistency();\n    \n    // Calculate overall quality\n    const quality = this.calculateOverallQuality(stability, vibrato, breathiness, consistency);\n    \n    // Generate recommendations\n    const recommendations = this.generateRecommendations(\n      quality,\n      stability,\n      vibrato,\n      breathiness,\n      consistency\n    );\n\n    return {\n      quality,\n      stability,\n      recommendations\n    };\n  }\n\n  /**\n   * Calculate pitch stability\n   */\n  private calculateStability(): number {\n    if (this.analysisBuffer.length < 10) {\n      return 0.5; // Neutral stability for insufficient data\n    }\n\n    const frequencies = this.analysisBuffer.map(entry => entry.frequency);\n    const validFrequencies = frequencies.filter(freq => freq > 0);\n    \n    if (validFrequencies.length < 5) {\n      return 0.3; // Low stability for sparse data\n    }\n\n    // Calculate coefficient of variation\n    const mean = validFrequencies.reduce((sum, freq) => sum + freq, 0) / validFrequencies.length;\n    const variance = validFrequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) / validFrequencies.length;\n    const standardDeviation = Math.sqrt(variance);\n    const coefficientOfVariation = standardDeviation / mean;\n    \n    // Convert to cents for musical relevance\n    const deviationCents = coefficientOfVariation * 1200;\n    \n    // Map to 0-1 stability score\n    return Math.max(0, Math.min(1, 1 - (deviationCents / 100)));\n  }\n\n  /**\n   * Detect vibrato characteristics\n   */\n  private detectVibrato(): {\n    detected: boolean;\n    rate: number | null;\n    depth: number | null;\n    regularity: number | null;\n  } {\n    if (this.analysisBuffer.length < 30) {\n      return { detected: false, rate: null, depth: null, regularity: null };\n    }\n\n    const frequencies = this.analysisBuffer.map(entry => entry.frequency).filter(f => f > 0);\n    if (frequencies.length < 20) {\n      return { detected: false, rate: null, depth: null, regularity: null };\n    }\n\n    // Smooth the frequency data\n    const smoothed = this.smoothFrequencies(frequencies, 3);\n    \n    // Find peaks and valleys\n    const extrema = this.findExtrema(smoothed);\n    \n    if (extrema.length < 4) {\n      return { detected: false, rate: null, depth: null, regularity: null };\n    }\n\n    // Calculate vibrato rate (cycles per second)\n    const timeSpan = (this.analysisBuffer[this.analysisBuffer.length - 1].timestamp - \n                     this.analysisBuffer[0].timestamp) / 1000;\n    const cycles = extrema.length / 2; // pairs of peaks and valleys\n    const rate = cycles / timeSpan;\n\n    // Calculate vibrato depth (in cents)\n    const depths = [];\n    for (let i = 0; i < extrema.length - 1; i++) {\n      const freq1 = smoothed[extrema[i].index];\n      const freq2 = smoothed[extrema[i + 1].index];\n      if (freq1 > 0 && freq2 > 0) {\n        const cents = Math.abs(1200 * Math.log2(freq1 / freq2));\n        depths.push(cents);\n      }\n    }\n\n    const averageDepth = depths.length > 0 ? \n      depths.reduce((sum, depth) => sum + depth, 0) / depths.length : 0;\n\n    // Calculate regularity (consistency of periods)\n    const periods = [];\n    for (let i = 0; i < extrema.length - 2; i += 2) {\n      const period = extrema[i + 2].index - extrema[i].index;\n      periods.push(period);\n    }\n\n    let regularity = 0;\n    if (periods.length > 2) {\n      const periodMean = periods.reduce((sum, p) => sum + p, 0) / periods.length;\n      const periodVariance = periods.reduce((sum, p) => sum + Math.pow(p - periodMean, 2), 0) / periods.length;\n      regularity = Math.max(0, 1 - (Math.sqrt(periodVariance) / periodMean));\n    }\n\n    // Determine if vibrato is detected\n    const detected = rate >= this.config.vibratoMinRate && \n                    rate <= this.config.vibratoMaxRate &&\n                    averageDepth >= this.config.vibratoMinDepthCents;\n\n    return {\n      detected,\n      rate: rate,\n      depth: averageDepth,\n      regularity\n    };\n  }\n\n  /**\n   * Analyze breathiness from spectral data\n   */\n  private analyzeBreathiness(spectralData: Float32Array): number {\n    // Analyze high-frequency noise content relative to fundamental\n    const fundamentalBin = Math.floor(spectralData.length * 0.1); // Rough estimate\n    const noiseBins = spectralData.slice(Math.floor(spectralData.length * 0.7)); // High frequency content\n    \n    const fundamentalEnergy = spectralData.slice(0, fundamentalBin * 2)\n      .reduce((sum, val) => sum + val * val, 0);\n    \n    const noiseEnergy = noiseBins.reduce((sum, val) => sum + val * val, 0);\n    \n    if (fundamentalEnergy === 0) return 1.0; // Maximum breathiness if no fundamental\n    \n    const noiseRatio = noiseEnergy / fundamentalEnergy;\n    return Math.min(1.0, noiseRatio);\n  }\n\n  /**\n   * Analyze consistency over time\n   */\n  private analyzeConsistency(): number {\n    if (this.analysisBuffer.length < 10) return 0.5;\n\n    const volumes = this.analysisBuffer.map(entry => entry.volume);\n    const clarities = this.analysisBuffer.map(entry => entry.clarity);\n    \n    // Calculate consistency metrics\n    const volumeConsistency = this.calculateConsistencyScore(volumes);\n    const clarityConsistency = this.calculateConsistencyScore(clarities);\n    \n    return (volumeConsistency + clarityConsistency) / 2;\n  }\n\n  /**\n   * Calculate consistency score for an array of values\n   */\n  private calculateConsistencyScore(values: number[]): number {\n    if (values.length < 3) return 0.5;\n\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    const coefficientOfVariation = Math.sqrt(variance) / (mean || 1);\n    \n    return Math.max(0, Math.min(1, 1 - coefficientOfVariation));\n  }\n\n  /**\n   * Calculate overall voice quality\n   */\n  private calculateOverallQuality(\n    stability: number,\n    vibrato: any,\n    breathiness: number | null,\n    consistency: number\n  ): VoiceQuality {\n    // Weight factors for different aspects\n    const weights = {\n      stability: 0.4,\n      consistency: 0.3,\n      breathiness: 0.2,\n      vibrato: 0.1\n    };\n\n    let score = stability * weights.stability + consistency * weights.consistency;\n    \n    // Breathiness penalty (lower is better for breathiness)\n    if (breathiness !== null) {\n      score += (1 - Math.min(breathiness, 1)) * weights.breathiness;\n    } else {\n      score += 0.7 * weights.breathiness; // Neutral if no data\n    }\n    \n    // Vibrato bonus for controlled vibrato\n    if (vibrato.detected && vibrato.regularity > 0.7) {\n      score += 0.9 * weights.vibrato;\n    } else if (vibrato.detected) {\n      score += 0.6 * weights.vibrato;\n    } else {\n      score += 0.5 * weights.vibrato;\n    }\n\n    // Map score to quality levels\n    if (score >= 0.85) return VoiceQuality.EXCELLENT;\n    if (score >= 0.7) return VoiceQuality.GOOD;\n    if (score >= 0.5) return VoiceQuality.FAIR;\n    return VoiceQuality.POOR;\n  }\n\n  /**\n   * Generate recommendations based on analysis\n   */\n  private generateRecommendations(\n    quality: VoiceQuality,\n    stability: number,\n    vibrato: any,\n    breathiness: number | null,\n    consistency: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Stability recommendations\n    if (stability < 0.5) {\n      recommendations.push('音程の安定性を向上させるため、ゆっくりとした発声練習を行ってください');\n      recommendations.push('腹式呼吸を意識して、息の流れを一定に保つ練習をしてください');\n    } else if (stability < 0.7) {\n      recommendations.push('音程の微調整練習で、より正確なピッチコントロールを目指しましょう');\n    }\n\n    // Consistency recommendations\n    if (consistency < 0.5) {\n      recommendations.push('音量と音質の一貫性を保つため、定期的な発声練習を継続してください');\n      recommendations.push('録音を聞き返して、自分の声の特徴を把握しましょう');\n    }\n\n    // Breathiness recommendations\n    if (breathiness !== null && breathiness > 0.6) {\n      recommendations.push('声の息漏れが気になります。発声時の喉の締まりを意識してください');\n      recommendations.push('ハミング練習で、クリアな声質を目指しましょう');\n    }\n\n    // Vibrato recommendations\n    if (vibrato.detected) {\n      if (vibrato.regularity < 0.5) {\n        recommendations.push('ビブラートの規則性を改善するため、メトロノームに合わせた練習をしてください');\n      } else if (vibrato.rate > 7.5) {\n        recommendations.push('ビブラートの速度が速すぎます。よりゆったりとしたビブラートを練習してください');\n      }\n    } else if (quality === VoiceQuality.GOOD || quality === VoiceQuality.EXCELLENT) {\n      recommendations.push('美しいビブラートの習得に挑戦してみましょう');\n    }\n\n    // General recommendations based on quality\n    if (quality === VoiceQuality.POOR) {\n      recommendations.push('基礎的な発声練習から始めることをお勧めします');\n      recommendations.push('専門的な指導を受けることを検討してください');\n    } else if (quality === VoiceQuality.EXCELLENT) {\n      recommendations.push('素晴らしい声質です。この状態を維持する練習を続けてください');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Smooth frequency data using moving average\n   */\n  private smoothFrequencies(frequencies: number[], windowSize: number): number[] {\n    const smoothed: number[] = [];\n    \n    for (let i = 0; i < frequencies.length; i++) {\n      let sum = 0;\n      let count = 0;\n      \n      const start = Math.max(0, i - Math.floor(windowSize / 2));\n      const end = Math.min(frequencies.length, i + Math.floor(windowSize / 2) + 1);\n      \n      for (let j = start; j < end; j++) {\n        sum += frequencies[j];\n        count++;\n      }\n      \n      smoothed.push(sum / count);\n    }\n    \n    return smoothed;\n  }\n\n  /**\n   * Find local extrema (peaks and valleys) in frequency data\n   */\n  private findExtrema(data: number[]): Array<{ index: number; value: number; type: 'peak' | 'valley' }> {\n    const extrema: Array<{ index: number; value: number; type: 'peak' | 'valley' }> = [];\n    \n    for (let i = 1; i < data.length - 1; i++) {\n      const prev = data[i - 1];\n      const curr = data[i];\n      const next = data[i + 1];\n      \n      if (curr > prev && curr > next) {\n        extrema.push({ index: i, value: curr, type: 'peak' });\n      } else if (curr < prev && curr < next) {\n        extrema.push({ index: i, value: curr, type: 'valley' });\n      }\n    }\n    \n    return extrema;\n  }\n\n  /**\n   * Add data to analysis buffer\n   */\n  private addToBuffer(frequency: number, volume: number, clarity: number, timestamp: number): void {\n    this.analysisBuffer.push({ frequency, volume, clarity, timestamp });\n    \n    // Limit buffer size\n    if (this.analysisBuffer.length > 200) {\n      this.analysisBuffer.shift();\n    }\n  }\n\n  /**\n   * Clean old data from buffer\n   */\n  private cleanBuffer(currentTime: number): void {\n    const cutoffTime = currentTime - this.config.analysisWindowMs;\n    this.analysisBuffer = this.analysisBuffer.filter(entry => entry.timestamp > cutoffTime);\n  }\n\n  /**\n   * Reset analysis buffer\n   */\n  reset(): void {\n    this.analysisBuffer = [];\n  }\n\n  /**\n   * Get current buffer statistics\n   */\n  getBufferStats(): {\n    entryCount: number;\n    timeSpanMs: number;\n    averageVolume: number;\n    averageClarity: number;\n  } {\n    if (this.analysisBuffer.length === 0) {\n      return { entryCount: 0, timeSpanMs: 0, averageVolume: 0, averageClarity: 0 };\n    }\n\n    const volumes = this.analysisBuffer.map(entry => entry.volume);\n    const clarities = this.analysisBuffer.map(entry => entry.clarity);\n    const timeSpan = this.analysisBuffer[this.analysisBuffer.length - 1].timestamp - this.analysisBuffer[0].timestamp;\n\n    return {\n      entryCount: this.analysisBuffer.length,\n      timeSpanMs: timeSpan,\n      averageVolume: volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length,\n      averageClarity: clarities.reduce((sum, clarity) => sum + clarity, 0) / clarities.length\n    };\n  }\n}","/**\n * CalibrationSystem - Device-specific audio calibration and optimization\n * \n * Automatically calibrates audio processing parameters based on device capabilities\n * Handles microphone sensitivity, noise characteristics, and frequency response\n */\n\nimport type { DeviceSpecs } from '../types';\nimport { DeviceDetection } from '../utils/DeviceDetection';\n\nexport class CalibrationSystem {\n  private deviceSpecs: DeviceSpecs;\n  private calibrationData: {\n    volumeOffset: number;\n    frequencyResponse: { [frequency: number]: number };\n    noiseProfile: { [frequency: number]: number };\n    optimalSettings: {\n      sensitivity: number;\n      noiseGate: number;\n      filterSettings: any;\n    };\n  } | null = null;\n\n  private isCalibrated = false;\n  private calibrationInProgress = false;\n\n  constructor() {\n    this.deviceSpecs = DeviceDetection.getDeviceSpecs();\n  }\n\n  /**\n   * Perform automatic calibration\n   */\n  async calibrate(audioContext: AudioContext, mediaStream: MediaStream): Promise<{\n    success: boolean;\n    calibrationData: any;\n    recommendedSettings: any;\n    error?: Error;\n  }> {\n    if (this.calibrationInProgress) {\n      throw new Error('Calibration already in progress');\n    }\n\n    this.calibrationInProgress = true;\n\n    try {\n      console.log('🎛️ [CalibrationSystem] Starting device calibration');\n\n      // Step 1: Measure background noise\n      const noiseProfile = await this.measureBackgroundNoise(audioContext, mediaStream);\n\n      // Step 2: Calibrate volume levels\n      const volumeCalibration = await this.calibrateVolumeLevels(audioContext, mediaStream);\n\n      // Step 3: Measure frequency response (simplified)\n      const frequencyResponse = await this.measureFrequencyResponse(audioContext, mediaStream);\n\n      // Step 4: Determine optimal settings\n      const optimalSettings = this.calculateOptimalSettings(\n        noiseProfile,\n        volumeCalibration,\n        frequencyResponse\n      );\n\n      this.calibrationData = {\n        volumeOffset: volumeCalibration.offset,\n        frequencyResponse,\n        noiseProfile,\n        optimalSettings\n      };\n\n      this.isCalibrated = true;\n      this.calibrationInProgress = false;\n\n      console.log('✅ [CalibrationSystem] Calibration completed successfully');\n\n      return {\n        success: true,\n        calibrationData: this.calibrationData,\n        recommendedSettings: optimalSettings\n      };\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Calibration failed:', error);\n      this.calibrationInProgress = false;\n      \n      return {\n        success: false,\n        calibrationData: null,\n        recommendedSettings: this.getDefaultSettings(),\n        error: error as Error\n      };\n    }\n  }\n\n  /**\n   * Measure background noise levels\n   */\n  private async measureBackgroundNoise(\n    audioContext: AudioContext,\n    mediaStream: MediaStream,\n    durationMs: number = 2000\n  ): Promise<{ [frequency: number]: number }> {\n    return new Promise((resolve) => {\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 2048;\n      \n      const source = audioContext.createMediaStreamSource(mediaStream);\n      source.connect(analyser);\n\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Float32Array(bufferLength);\n      const measurements: Float32Array[] = [];\n\n      const startTime = Date.now();\n\n      const measureNoise = () => {\n        if (Date.now() - startTime >= durationMs) {\n          // Calculate average noise profile\n          const avgNoise: { [frequency: number]: number } = {};\n          \n          for (let bin = 0; bin < bufferLength; bin++) {\n            const frequency = (bin * audioContext.sampleRate) / (analyser.fftSize);\n            let sum = 0;\n            \n            for (const measurement of measurements) {\n              sum += measurement[bin];\n            }\n            \n            avgNoise[Math.round(frequency)] = sum / measurements.length;\n          }\n\n          source.disconnect();\n          resolve(avgNoise);\n          return;\n        }\n\n        analyser.getFloatFrequencyData(dataArray);\n        measurements.push(new Float32Array(dataArray));\n        \n        setTimeout(measureNoise, 100);\n      };\n\n      measureNoise();\n    });\n  }\n\n  /**\n   * Calibrate volume levels\n   */\n  private async calibrateVolumeLevels(\n    audioContext: AudioContext,\n    mediaStream: MediaStream,\n    durationMs: number = 3000\n  ): Promise<{ offset: number; range: { min: number; max: number } }> {\n    return new Promise((resolve) => {\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 1024;\n      \n      const source = audioContext.createMediaStreamSource(mediaStream);\n      source.connect(analyser);\n\n      const bufferLength = analyser.fftSize;\n      const dataArray = new Float32Array(bufferLength);\n      const volumeMeasurements: number[] = [];\n\n      const startTime = Date.now();\n\n      const measureVolume = () => {\n        if (Date.now() - startTime >= durationMs) {\n          // Analyze volume distribution\n          volumeMeasurements.sort((a, b) => a - b);\n          \n          const min = volumeMeasurements[0] || 0;\n          const max = volumeMeasurements[volumeMeasurements.length - 1] || 1;\n          const median = volumeMeasurements[Math.floor(volumeMeasurements.length / 2)] || 0.5;\n          \n          // Calculate offset to center dynamic range\n          const targetCenter = 0.3; // Aim for 30% as comfortable speaking level\n          const offset = targetCenter - median;\n\n          source.disconnect();\n          resolve({\n            offset,\n            range: { min, max }\n          });\n          return;\n        }\n\n        analyser.getFloatTimeDomainData(dataArray);\n        \n        // Calculate RMS\n        let sum = 0;\n        for (let i = 0; i < bufferLength; i++) {\n          sum += dataArray[i] * dataArray[i];\n        }\n        const rms = Math.sqrt(sum / bufferLength);\n        volumeMeasurements.push(rms);\n        \n        setTimeout(measureVolume, 50);\n      };\n\n      measureVolume();\n    });\n  }\n\n  /**\n   * Measure frequency response (simplified version)\n   */\n  private async measureFrequencyResponse(\n    audioContext: AudioContext,\n    mediaStream: MediaStream,\n    durationMs: number = 5000\n  ): Promise<{ [frequency: number]: number }> {\n    return new Promise((resolve) => {\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 4096;\n      \n      const source = audioContext.createMediaStreamSource(mediaStream);\n      source.connect(analyser);\n\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Float32Array(bufferLength);\n      const responseMap: { [frequency: number]: number[] } = {};\n\n      const startTime = Date.now();\n\n      const measureResponse = () => {\n        if (Date.now() - startTime >= durationMs) {\n          // Calculate average response for each frequency\n          const avgResponse: { [frequency: number]: number } = {};\n          \n          Object.keys(responseMap).forEach(freqStr => {\n            const frequency = parseInt(freqStr);\n            const measurements = responseMap[frequency];\n            const avg = measurements.reduce((sum, val) => sum + val, 0) / measurements.length;\n            avgResponse[frequency] = avg;\n          });\n\n          source.disconnect();\n          resolve(avgResponse);\n          return;\n        }\n\n        analyser.getFloatFrequencyData(dataArray);\n        \n        // Store measurements for key frequencies\n        for (let bin = 0; bin < bufferLength; bin++) {\n          const frequency = Math.round((bin * audioContext.sampleRate) / (analyser.fftSize));\n          \n          // Focus on vocal range\n          if (frequency >= 80 && frequency <= 1000) {\n            if (!responseMap[frequency]) {\n              responseMap[frequency] = [];\n            }\n            responseMap[frequency].push(dataArray[bin]);\n          }\n        }\n        \n        setTimeout(measureResponse, 100);\n      };\n\n      measureResponse();\n    });\n  }\n\n  /**\n   * Calculate optimal settings based on calibration data\n   */\n  private calculateOptimalSettings(\n    noiseProfile: { [frequency: number]: number },\n    volumeCalibration: any,\n    frequencyResponse: { [frequency: number]: number }\n  ): any {\n    const baseSettings = this.getDefaultSettings();\n\n    // Adjust sensitivity based on volume calibration\n    const sensitivityAdjustment = Math.max(0.5, Math.min(2.0, 1.0 - volumeCalibration.offset));\n    const adjustedSensitivity = baseSettings.sensitivity * sensitivityAdjustment;\n\n    // Adjust noise gate based on background noise\n    const noiseFrequencies = Object.keys(noiseProfile).map(f => parseInt(f));\n    const vocalRangeNoise = noiseFrequencies\n      .filter(f => f >= 100 && f <= 800)\n      .map(f => noiseProfile[f]);\n    \n    const avgNoise = vocalRangeNoise.length > 0 ? \n      vocalRangeNoise.reduce((sum, val) => sum + val, 0) / vocalRangeNoise.length : -60;\n    \n    const noiseGateAdjustment = Math.max(-20, avgNoise + 10); // 10dB above average noise\n    const adjustedNoiseGate = Math.max(baseSettings.noiseGate, Math.abs(noiseGateAdjustment) / 1000);\n\n    // Analyze frequency response for filter adjustments\n    const frequencyKeys = Object.keys(frequencyResponse).map(f => parseInt(f)).sort((a, b) => a - b);\n    const responseLevels = frequencyKeys.map(f => frequencyResponse[f]);\n    \n    // Simple frequency response correction\n    const lowFreqResponse = responseLevels.slice(0, Math.floor(responseLevels.length * 0.3));\n    const midFreqResponse = responseLevels.slice(\n      Math.floor(responseLevels.length * 0.3),\n      Math.floor(responseLevels.length * 0.7)\n    );\n    const highFreqResponse = responseLevels.slice(Math.floor(responseLevels.length * 0.7));\n\n    const lowAvg = lowFreqResponse.reduce((sum, val) => sum + val, 0) / lowFreqResponse.length;\n    const midAvg = midFreqResponse.reduce((sum, val) => sum + val, 0) / midFreqResponse.length;\n    const highAvg = highFreqResponse.reduce((sum, val) => sum + val, 0) / highFreqResponse.length;\n\n    return {\n      sensitivity: Math.round(adjustedSensitivity * 10) / 10,\n      noiseGate: Math.round(adjustedNoiseGate * 1000) / 1000,\n      volumeOffset: volumeCalibration.offset,\n      filterSettings: {\n        highpassFreq: lowAvg < (midAvg - 5) ? 100 : 80, // Stronger highpass if low freq is weak\n        lowpassFreq: highAvg > (midAvg + 3) ? 600 : 800, // Lower cutoff if high freq is strong\n        notchFreq: 60, // Standard power line frequency\n        highpassQ: 0.7,\n        lowpassQ: 0.7,\n        notchQ: 10.0\n      },\n      deviceAdjustments: {\n        lowFreqCompensation: Math.max(0.8, Math.min(1.5, midAvg / (lowAvg || -60))),\n        highFreqCompensation: Math.max(0.8, Math.min(1.2, midAvg / (highAvg || -60)))\n      }\n    };\n  }\n\n  /**\n   * Get default settings for current device\n   */\n  private getDefaultSettings(): any {\n    return {\n      sensitivity: this.deviceSpecs.sensitivity,\n      noiseGate: this.deviceSpecs.noiseGate,\n      volumeOffset: 0,\n      filterSettings: {\n        highpassFreq: 80,\n        lowpassFreq: 800,\n        notchFreq: 60,\n        highpassQ: 0.7,\n        lowpassQ: 0.7,\n        notchQ: 10.0\n      }\n    };\n  }\n\n  /**\n   * Apply calibrated settings to audio processing\n   */\n  applyCalibration(audioProcessor: any): boolean {\n    if (!this.isCalibrated || !this.calibrationData) {\n      console.warn('⚠️ [CalibrationSystem] No calibration data available');\n      return false;\n    }\n\n    try {\n      const settings = this.calibrationData.optimalSettings;\n      \n      // Apply settings to audio processor\n      if (audioProcessor.setSensitivity) {\n        audioProcessor.setSensitivity(settings.sensitivity);\n      }\n      \n      if (audioProcessor.setNoiseGate) {\n        audioProcessor.setNoiseGate(settings.noiseGate);\n      }\n      \n      if (audioProcessor.updateFilterSettings) {\n        audioProcessor.updateFilterSettings(settings.filterSettings);\n      }\n\n      console.log('✅ [CalibrationSystem] Calibration applied successfully');\n      return true;\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Failed to apply calibration:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get calibration status\n   */\n  getCalibrationStatus(): {\n    isCalibrated: boolean;\n    inProgress: boolean;\n    deviceSpecs: DeviceSpecs;\n    calibrationData: any;\n  } {\n    return {\n      isCalibrated: this.isCalibrated,\n      inProgress: this.calibrationInProgress,\n      deviceSpecs: this.deviceSpecs,\n      calibrationData: this.calibrationData\n    };\n  }\n\n  /**\n   * Reset calibration\n   */\n  reset(): void {\n    this.isCalibrated = false;\n    this.calibrationInProgress = false;\n    this.calibrationData = null;\n    \n    console.log('🔄 [CalibrationSystem] Calibration reset');\n  }\n\n  /**\n   * Save calibration data to localStorage\n   */\n  saveCalibration(): boolean {\n    if (!this.isCalibrated || !this.calibrationData) {\n      return false;\n    }\n\n    try {\n      const calibrationKey = `pitchpro_calibration_${this.deviceSpecs.deviceType}`;\n      const dataToSave = {\n        deviceSpecs: this.deviceSpecs,\n        calibrationData: this.calibrationData,\n        timestamp: Date.now()\n      };\n\n      localStorage.setItem(calibrationKey, JSON.stringify(dataToSave));\n      console.log('💾 [CalibrationSystem] Calibration saved');\n      return true;\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Failed to save calibration:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Load calibration data from localStorage\n   */\n  loadCalibration(): boolean {\n    try {\n      const calibrationKey = `pitchpro_calibration_${this.deviceSpecs.deviceType}`;\n      const savedData = localStorage.getItem(calibrationKey);\n      \n      if (!savedData) {\n        return false;\n      }\n\n      const parsedData = JSON.parse(savedData);\n      \n      // Check if calibration is recent (within 7 days)\n      const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n      if (Date.now() - parsedData.timestamp > maxAge) {\n        console.log('⏰ [CalibrationSystem] Saved calibration is too old, ignoring');\n        return false;\n      }\n\n      // Verify device compatibility\n      if (parsedData.deviceSpecs.deviceType !== this.deviceSpecs.deviceType) {\n        console.log('📱 [CalibrationSystem] Device type mismatch, ignoring saved calibration');\n        return false;\n      }\n\n      this.calibrationData = parsedData.calibrationData;\n      this.isCalibrated = true;\n      \n      console.log('📂 [CalibrationSystem] Calibration loaded successfully');\n      return true;\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Failed to load calibration:', error);\n      return false;\n    }\n  }\n}"],"names":["HarmonicCorrection","config","frequency","volume","now","analysis","recentFrequencies","entry","fundamentalCandidates","bestCandidate","candidate","confidence","candidates","harmonicNum","fundamental","exactHarmonic","centDeviation","likelihood","a","b","_harmonicNumber","totalConfidence","validMeasurements","freq","closestHarmonicNum","expectedFreq","avgConfidence","stabilityBonus","timestamp","volumeConfidence","stabilityConfidence","lastFreq","freqRatio","currentTime","cutoffTime","frequencies","confidences","sum","conf","minFreq","maxFreq","mean","variance","coefficientOfVariation","stabilityScore","newConfig","VoiceQuality","VoiceAnalyzer","clarity","spectralData","stability","vibrato","breathiness","consistency","quality","recommendations","validFrequencies","deviationCents","f","smoothed","extrema","timeSpan","rate","depths","i","freq1","freq2","cents","averageDepth","depth","periods","period","regularity","periodMean","p","periodVariance","fundamentalBin","noiseBins","fundamentalEnergy","val","noiseEnergy","noiseRatio","volumes","clarities","volumeConsistency","clarityConsistency","values","weights","score","windowSize","count","start","end","j","data","prev","curr","next","vol","CalibrationSystem","DeviceDetection","audioContext","mediaStream","noiseProfile","volumeCalibration","frequencyResponse","optimalSettings","error","durationMs","resolve","analyser","source","bufferLength","dataArray","measurements","startTime","measureNoise","avgNoise","bin","measurement","volumeMeasurements","measureVolume","min","max","offset","rms","responseMap","measureResponse","avgResponse","freqStr","avg","baseSettings","sensitivityAdjustment","adjustedSensitivity","vocalRangeNoise","noiseGateAdjustment","adjustedNoiseGate","responseLevels","lowFreqResponse","midFreqResponse","highFreqResponse","lowAvg","midAvg","highAvg","audioProcessor","settings","calibrationKey","dataToSave","savedData","parsedData","maxAge"],"mappings":"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"}