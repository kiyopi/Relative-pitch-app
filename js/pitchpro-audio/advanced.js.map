{"version":3,"file":"advanced.js","sources":["../src/advanced/HarmonicCorrection.ts","../src/types/index.ts","../src/advanced/VoiceAnalyzer.ts","../src/advanced/CalibrationSystem.ts"],"sourcesContent":["/**\n * HarmonicCorrection - Advanced harmonic detection and correction\n * \n * Provides sophisticated harmonic analysis and correction algorithms\n * Handles complex harmonic patterns, subharmonics, and frequency drift\n */\n\nimport type { HarmonicCorrectionResult } from '../types';\n\nexport class HarmonicCorrection {\n  private historyBuffer: Array<{\n    frequency: number;\n    confidence: number;\n    timestamp: number;\n    volume: number;\n  }> = [];\n  \n  private config = {\n    historyWindowMs: 2000,\n    minConfidenceThreshold: 0.6,\n    harmonicToleranceCents: 30,\n    maxHarmonicNumber: 8,\n    stabilityWeight: 0.7,\n    volumeWeight: 0.3\n  };\n\n  constructor(config: Partial<typeof HarmonicCorrection.prototype.config> = {}) {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Apply harmonic correction to detected frequency\n   */\n  correctFrequency(frequency: number, volume: number = 1.0): HarmonicCorrectionResult {\n    const now = Date.now();\n    \n    // Clean old history\n    this.cleanHistory(now);\n    \n    // Add current detection to history\n    this.addToHistory(frequency, volume, now);\n    \n    // Analyze for harmonic patterns\n    const analysis = this.analyzeHarmonics(frequency);\n    \n    // Apply correction if confidence is high enough\n    if (analysis.confidence >= this.config.minConfidenceThreshold) {\n      return {\n        correctedFreq: analysis.correctedFrequency,\n        confidence: analysis.confidence,\n        correctionApplied: Math.abs(analysis.correctedFrequency - frequency) > 1.0\n      };\n    }\n    \n    return {\n      correctedFreq: frequency,\n      confidence: analysis.confidence,\n      correctionApplied: false\n    };\n  }\n\n  /**\n   * Analyze frequency for harmonic patterns\n   */\n  private analyzeHarmonics(frequency: number): {\n    correctedFrequency: number;\n    confidence: number;\n    harmonicNumber?: number;\n    fundamentalCandidate?: number;\n  } {\n    if (this.historyBuffer.length < 3) {\n      return {\n        correctedFrequency: frequency,\n        confidence: 0.1\n      };\n    }\n\n    // Get recent stable frequencies\n    const recentFrequencies = this.historyBuffer\n      .slice(-10)\n      .map(entry => entry.frequency);\n\n    // Look for fundamental candidates\n    const fundamentalCandidates = this.findFundamentalCandidates(frequency);\n    \n    let bestCandidate = {\n      frequency,\n      confidence: 0.1,\n      harmonicNumber: 1\n    };\n\n    // Test each fundamental candidate\n    for (const candidate of fundamentalCandidates) {\n      const confidence = this.calculateHarmonicConfidence(\n        candidate.fundamental,\n        candidate.harmonicNumber,\n        recentFrequencies\n      );\n      \n      if (confidence > bestCandidate.confidence) {\n        bestCandidate = {\n          frequency: candidate.fundamental,\n          confidence,\n          harmonicNumber: candidate.harmonicNumber\n        };\n      }\n    }\n\n    // If we found a likely harmonic, correct to fundamental\n    if (bestCandidate.harmonicNumber > 1 && bestCandidate.confidence > this.config.minConfidenceThreshold) {\n      return {\n        correctedFrequency: bestCandidate.frequency,\n        confidence: bestCandidate.confidence,\n        harmonicNumber: bestCandidate.harmonicNumber,\n        fundamentalCandidate: bestCandidate.frequency\n      };\n    }\n\n    return {\n      correctedFrequency: frequency,\n      confidence: bestCandidate.confidence\n    };\n  }\n\n  /**\n   * Find potential fundamental frequencies for a given detected frequency\n   */\n  private findFundamentalCandidates(frequency: number): Array<{\n    fundamental: number;\n    harmonicNumber: number;\n    likelihood: number;\n  }> {\n    const candidates: Array<{\n      fundamental: number;\n      harmonicNumber: number;\n      likelihood: number;\n    }> = [];\n\n    // Check if this could be a harmonic of a lower fundamental\n    for (let harmonicNum = 2; harmonicNum <= this.config.maxHarmonicNumber; harmonicNum++) {\n      const fundamental = frequency / harmonicNum;\n      \n      // Skip if fundamental is too low for human voice\n      if (fundamental < 60) continue;\n      \n      // Calculate likelihood based on how close it is to exact harmonic ratio\n      const exactHarmonic = fundamental * harmonicNum;\n      const centDeviation = Math.abs(1200 * Math.log2(frequency / exactHarmonic));\n      \n      if (centDeviation <= this.config.harmonicToleranceCents) {\n        const likelihood = 1.0 - (centDeviation / this.config.harmonicToleranceCents);\n        candidates.push({\n          fundamental,\n          harmonicNumber: harmonicNum,\n          likelihood\n        });\n      }\n    }\n\n    // Also consider the frequency itself as fundamental (no correction)\n    candidates.push({\n      fundamental: frequency,\n      harmonicNumber: 1,\n      likelihood: 0.5\n    });\n\n    return candidates.sort((a, b) => b.likelihood - a.likelihood);\n  }\n\n  /**\n   * Calculate confidence that a frequency pattern represents a harmonic series\n   */\n  private calculateHarmonicConfidence(\n    fundamental: number,\n    _harmonicNumber: number,\n    recentFrequencies: number[]\n  ): number {\n    if (recentFrequencies.length < 3) return 0.1;\n\n    let totalConfidence = 0;\n    let validMeasurements = 0;\n\n    // Check how well recent frequencies fit the harmonic pattern\n    for (const freq of recentFrequencies) {\n      // Find the closest harmonic to this frequency\n      let closestHarmonicNum = Math.round(freq / fundamental);\n      if (closestHarmonicNum < 1) closestHarmonicNum = 1;\n      \n      const expectedFreq = fundamental * closestHarmonicNum;\n      const centDeviation = Math.abs(1200 * Math.log2(freq / expectedFreq));\n      \n      if (centDeviation <= this.config.harmonicToleranceCents * 2) {\n        const confidence = 1.0 - (centDeviation / (this.config.harmonicToleranceCents * 2));\n        totalConfidence += confidence;\n        validMeasurements++;\n      }\n    }\n\n    if (validMeasurements === 0) return 0.1;\n\n    // Average confidence, weighted by stability\n    const avgConfidence = totalConfidence / validMeasurements;\n    \n    // Add stability bonus if we have consistent measurements\n    const stabilityBonus = Math.min(validMeasurements / recentFrequencies.length, 1.0);\n    \n    return Math.min(avgConfidence * this.config.stabilityWeight + stabilityBonus * (1 - this.config.stabilityWeight), 1.0);\n  }\n\n  /**\n   * Add frequency detection to history\n   */\n  private addToHistory(frequency: number, volume: number, timestamp: number): void {\n    // Calculate confidence based on volume and stability\n    const volumeConfidence = Math.min(volume, 1.0);\n    let stabilityConfidence = 0.5;\n    \n    if (this.historyBuffer.length > 0) {\n      const lastFreq = this.historyBuffer[this.historyBuffer.length - 1].frequency;\n      const freqRatio = Math.max(frequency, lastFreq) / Math.min(frequency, lastFreq);\n      stabilityConfidence = Math.max(0, 1.0 - (freqRatio - 1.0) * 5); // Penalty for large jumps\n    }\n    \n    const confidence = volumeConfidence * this.config.volumeWeight + \n                      stabilityConfidence * (1 - this.config.volumeWeight);\n    \n    this.historyBuffer.push({\n      frequency,\n      confidence,\n      timestamp,\n      volume\n    });\n    \n    // Limit buffer size\n    if (this.historyBuffer.length > 50) {\n      this.historyBuffer.shift();\n    }\n  }\n\n  /**\n   * Clean old entries from history\n   */\n  private cleanHistory(currentTime: number): void {\n    const cutoffTime = currentTime - this.config.historyWindowMs;\n    this.historyBuffer = this.historyBuffer.filter(entry => entry.timestamp > cutoffTime);\n  }\n\n  /**\n   * Reset correction history\n   */\n  resetHistory(): void {\n    this.historyBuffer = [];\n  }\n\n  /**\n   * Get current analysis statistics\n   */\n  getAnalysisStats(): {\n    historyLength: number;\n    averageConfidence: number;\n    frequencyRange: { min: number; max: number } | null;\n    stabilityScore: number;\n  } {\n    if (this.historyBuffer.length === 0) {\n      return {\n        historyLength: 0,\n        averageConfidence: 0,\n        frequencyRange: null,\n        stabilityScore: 0\n      };\n    }\n\n    const frequencies = this.historyBuffer.map(entry => entry.frequency);\n    const confidences = this.historyBuffer.map(entry => entry.confidence);\n    \n    const avgConfidence = confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length;\n    const minFreq = Math.min(...frequencies);\n    const maxFreq = Math.max(...frequencies);\n    \n    // Calculate stability as inverse of coefficient of variation\n    const mean = frequencies.reduce((sum, freq) => sum + freq, 0) / frequencies.length;\n    const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) / frequencies.length;\n    const coefficientOfVariation = Math.sqrt(variance) / mean;\n    const stabilityScore = Math.max(0, 1.0 - coefficientOfVariation);\n\n    return {\n      historyLength: this.historyBuffer.length,\n      averageConfidence: avgConfidence,\n      frequencyRange: { min: minFreq, max: maxFreq },\n      stabilityScore\n    };\n  }\n\n  /**\n   * Configure correction parameters\n   */\n  updateConfig(newConfig: Partial<typeof this.config>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}","/**\n * TypeScript type definitions for PitchPro Audio Processing\n */\n\n// AudioManager types\nexport interface AudioManagerConfig {\n  sampleRate?: number;\n  channelCount?: number;\n  echoCancellation?: boolean;\n  noiseSuppression?: boolean;\n  autoGainControl?: boolean;\n  latency?: number;\n}\n\n// PitchDetector types\nexport interface PitchDetectorConfig {\n  fftSize?: number;\n  smoothing?: number;\n  clarityThreshold?: number;\n  minVolumeAbsolute?: number;\n}\n\nexport interface PitchDetectionResult {\n  frequency: number;\n  note: string;\n  clarity: number;\n  volume: number;\n  cents?: number;\n}\n\n// NoiseFilter types\nexport interface NoiseFilterConfig {\n  highpassFreq?: number;\n  lowpassFreq?: number;\n  notchFreq?: number;\n  highpassQ?: number;\n  lowpassQ?: number;\n  notchQ?: number;\n  useFilters?: boolean;\n}\n\n// HarmonicCorrection types\nexport interface HarmonicCorrectionResult {\n  correctedFreq: number;\n  confidence: number;\n  correctionApplied: boolean;\n}\n\n// ErrorNotification types\nexport interface NotificationConfig {\n  type: 'error' | 'warning' | 'success' | 'info';\n  title: string;\n  message: string;\n  details?: string[];\n  solution?: string;\n  autoHide?: boolean;\n  duration?: number;\n  priority?: 'low' | 'medium' | 'high';\n}\n\nexport interface NotificationElement extends HTMLElement {\n  'data-notification-id': string;\n}\n\n// Music theory types\nexport interface MusicalNote {\n  name: string;\n  octave: number;\n  midi: number;\n  frequency: number;\n}\n\nexport interface MusicalInterval {\n  name: string;\n  semitones: number;\n  cents: number;\n  ratio: number;\n}\n\n// Voice analysis types\nexport interface VoiceAnalysis {\n  quality: VoiceQuality;\n  stability: number;\n  recommendations: string[];\n}\n\nexport const VoiceQuality = {\n  EXCELLENT: 'excellent' as const,\n  GOOD: 'good' as const,\n  FAIR: 'fair' as const,\n  POOR: 'poor' as const\n};\n\nexport type VoiceQuality = typeof VoiceQuality[keyof typeof VoiceQuality];\n\nexport const AccuracyLevel = {\n  PERFECT: 'perfect' as const,\n  EXCELLENT: 'excellent' as const,\n  GOOD: 'good' as const,\n  FAIR: 'fair' as const,\n  POOR: 'poor' as const\n};\n\nexport type AccuracyLevel = typeof AccuracyLevel[keyof typeof AccuracyLevel];\n\nexport interface AccuracyResult {\n  accuracy: AccuracyLevel;\n  centsOff: number;\n  score: number;\n}\n\n// Device detection types\nexport interface DeviceSpecs {\n  deviceType: 'iPhone' | 'iPad' | 'PC';\n  isIOS: boolean;\n  sensitivity: number;\n  noiseGate: number;\n  divisor: number;\n  gainCompensation: number;\n  noiseThreshold: number;\n  smoothingFactor: number;\n}\n\n// Lifecycle management types\nexport interface MediaStreamResources {\n  audioContext: AudioContext;\n  mediaStream: MediaStream;\n  sourceNode: MediaStreamAudioSourceNode;\n}\n\nexport interface HealthStatus {\n  mediaStreamActive: boolean;\n  audioContextState: string;\n  trackStates: TrackState[];\n  healthy: boolean;\n  refCount?: number;\n}\n\nexport interface TrackState {\n  kind: string;\n  enabled: boolean;\n  readyState: MediaStreamTrackState;\n  muted: boolean;\n}\n\n// Event types\nexport interface MicrophoneControllerEvents {\n  'pitchpro:microphoneGranted': CustomEvent<{ stream: MediaStream }>;\n  'pitchpro:microphoneDenied': CustomEvent<{ error: Error }>;\n  'pitchpro:microphoneStopped': CustomEvent;\n  'pitchpro:sensitivityChanged': CustomEvent<{ sensitivity: number }>;\n  'pitchpro:noiseGateChanged': CustomEvent<{ threshold: number }>;\n  'pitchpro:deviceDetected': CustomEvent<{ specs: DeviceSpecs }>;\n}\n\nexport interface LifecycleEvents {\n  'pitchpro:lifecycle:trackEnded': CustomEvent<{ track: MediaStreamTrack }>;\n  'pitchpro:lifecycle:trackMuted': CustomEvent<{ track: MediaStreamTrack }>;\n  'pitchpro:lifecycle:trackUnmuted': CustomEvent<{ track: MediaStreamTrack }>;\n  'pitchpro:lifecycle:autoRecoverySuccess': CustomEvent;\n  'pitchpro:lifecycle:autoRecoveryFailed': CustomEvent<{ error: Error }>;\n}\n\n// Callback types\nexport type PitchCallback = (result: PitchDetectionResult) => void;\nexport type ErrorCallback = (error: Error) => void;\nexport type StateChangeCallback = (state: string) => void;","/**\n * VoiceAnalyzer - Advanced voice quality and analysis\n * \n * Analyzes voice characteristics, stability, and provides recommendations\n * Includes vibrato detection, breathiness analysis, and vocal health indicators\n */\n\nimport type { VoiceAnalysis } from '../types';\nimport { VoiceQuality } from '../types';\n\nexport class VoiceAnalyzer {\n  private analysisBuffer: Array<{\n    frequency: number;\n    volume: number;\n    clarity: number;\n    timestamp: number;\n  }> = [];\n  \n  private config = {\n    analysisWindowMs: 3000,\n    stabilityThresholdCents: 20,\n    vibratoMinRate: 4.5,\n    vibratoMaxRate: 7.5,\n    vibratoMinDepthCents: 50,\n    breathinessThreshold: 0.3,\n    minAnalysisTime: 1000\n  };\n\n  constructor(config: Partial<typeof VoiceAnalyzer.prototype.config> = {}) {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Analyze voice characteristics from audio data\n   */\n  analyzeVoice(\n    frequency: number, \n    volume: number, \n    clarity: number,\n    spectralData?: Float32Array\n  ): VoiceAnalysis {\n    const timestamp = Date.now();\n    \n    // Add to analysis buffer\n    this.addToBuffer(frequency, volume, clarity, timestamp);\n    \n    // Clean old data\n    this.cleanBuffer(timestamp);\n    \n    // Perform comprehensive analysis\n    const stability = this.calculateStability();\n    const vibrato = this.detectVibrato();\n    const breathiness = spectralData ? this.analyzeBreathiness(spectralData) : null;\n    const consistency = this.analyzeConsistency();\n    \n    // Calculate overall quality\n    const quality = this.calculateOverallQuality(stability, vibrato, breathiness, consistency);\n    \n    // Generate recommendations\n    const recommendations = this.generateRecommendations(\n      quality,\n      stability,\n      vibrato,\n      breathiness,\n      consistency\n    );\n\n    return {\n      quality,\n      stability,\n      recommendations\n    };\n  }\n\n  /**\n   * Calculate pitch stability\n   */\n  private calculateStability(): number {\n    if (this.analysisBuffer.length < 10) {\n      return 0.5; // Neutral stability for insufficient data\n    }\n\n    const frequencies = this.analysisBuffer.map(entry => entry.frequency);\n    const validFrequencies = frequencies.filter(freq => freq > 0);\n    \n    if (validFrequencies.length < 5) {\n      return 0.3; // Low stability for sparse data\n    }\n\n    // Calculate coefficient of variation\n    const mean = validFrequencies.reduce((sum, freq) => sum + freq, 0) / validFrequencies.length;\n    const variance = validFrequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) / validFrequencies.length;\n    const standardDeviation = Math.sqrt(variance);\n    const coefficientOfVariation = standardDeviation / mean;\n    \n    // Convert to cents for musical relevance\n    const deviationCents = coefficientOfVariation * 1200;\n    \n    // Map to 0-1 stability score\n    return Math.max(0, Math.min(1, 1 - (deviationCents / 100)));\n  }\n\n  /**\n   * Detect vibrato characteristics\n   */\n  private detectVibrato(): {\n    detected: boolean;\n    rate: number | null;\n    depth: number | null;\n    regularity: number | null;\n  } {\n    if (this.analysisBuffer.length < 30) {\n      return { detected: false, rate: null, depth: null, regularity: null };\n    }\n\n    const frequencies = this.analysisBuffer.map(entry => entry.frequency).filter(f => f > 0);\n    if (frequencies.length < 20) {\n      return { detected: false, rate: null, depth: null, regularity: null };\n    }\n\n    // Smooth the frequency data\n    const smoothed = this.smoothFrequencies(frequencies, 3);\n    \n    // Find peaks and valleys\n    const extrema = this.findExtrema(smoothed);\n    \n    if (extrema.length < 4) {\n      return { detected: false, rate: null, depth: null, regularity: null };\n    }\n\n    // Calculate vibrato rate (cycles per second)\n    const timeSpan = (this.analysisBuffer[this.analysisBuffer.length - 1].timestamp - \n                     this.analysisBuffer[0].timestamp) / 1000;\n    const cycles = extrema.length / 2; // pairs of peaks and valleys\n    const rate = cycles / timeSpan;\n\n    // Calculate vibrato depth (in cents)\n    const depths = [];\n    for (let i = 0; i < extrema.length - 1; i++) {\n      const freq1 = smoothed[extrema[i].index];\n      const freq2 = smoothed[extrema[i + 1].index];\n      if (freq1 > 0 && freq2 > 0) {\n        const cents = Math.abs(1200 * Math.log2(freq1 / freq2));\n        depths.push(cents);\n      }\n    }\n\n    const averageDepth = depths.length > 0 ? \n      depths.reduce((sum, depth) => sum + depth, 0) / depths.length : 0;\n\n    // Calculate regularity (consistency of periods)\n    const periods = [];\n    for (let i = 0; i < extrema.length - 2; i += 2) {\n      const period = extrema[i + 2].index - extrema[i].index;\n      periods.push(period);\n    }\n\n    let regularity = 0;\n    if (periods.length > 2) {\n      const periodMean = periods.reduce((sum, p) => sum + p, 0) / periods.length;\n      const periodVariance = periods.reduce((sum, p) => sum + Math.pow(p - periodMean, 2), 0) / periods.length;\n      regularity = Math.max(0, 1 - (Math.sqrt(periodVariance) / periodMean));\n    }\n\n    // Determine if vibrato is detected\n    const detected = rate >= this.config.vibratoMinRate && \n                    rate <= this.config.vibratoMaxRate &&\n                    averageDepth >= this.config.vibratoMinDepthCents;\n\n    return {\n      detected,\n      rate: rate,\n      depth: averageDepth,\n      regularity\n    };\n  }\n\n  /**\n   * Analyze breathiness from spectral data\n   */\n  private analyzeBreathiness(spectralData: Float32Array): number {\n    // Analyze high-frequency noise content relative to fundamental\n    const fundamentalBin = Math.floor(spectralData.length * 0.1); // Rough estimate\n    const noiseBins = spectralData.slice(Math.floor(spectralData.length * 0.7)); // High frequency content\n    \n    const fundamentalEnergy = spectralData.slice(0, fundamentalBin * 2)\n      .reduce((sum, val) => sum + val * val, 0);\n    \n    const noiseEnergy = noiseBins.reduce((sum, val) => sum + val * val, 0);\n    \n    if (fundamentalEnergy === 0) return 1.0; // Maximum breathiness if no fundamental\n    \n    const noiseRatio = noiseEnergy / fundamentalEnergy;\n    return Math.min(1.0, noiseRatio);\n  }\n\n  /**\n   * Analyze consistency over time\n   */\n  private analyzeConsistency(): number {\n    if (this.analysisBuffer.length < 10) return 0.5;\n\n    const volumes = this.analysisBuffer.map(entry => entry.volume);\n    const clarities = this.analysisBuffer.map(entry => entry.clarity);\n    \n    // Calculate consistency metrics\n    const volumeConsistency = this.calculateConsistencyScore(volumes);\n    const clarityConsistency = this.calculateConsistencyScore(clarities);\n    \n    return (volumeConsistency + clarityConsistency) / 2;\n  }\n\n  /**\n   * Calculate consistency score for an array of values\n   */\n  private calculateConsistencyScore(values: number[]): number {\n    if (values.length < 3) return 0.5;\n\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    const coefficientOfVariation = Math.sqrt(variance) / (mean || 1);\n    \n    return Math.max(0, Math.min(1, 1 - coefficientOfVariation));\n  }\n\n  /**\n   * Calculate overall voice quality\n   */\n  private calculateOverallQuality(\n    stability: number,\n    vibrato: any,\n    breathiness: number | null,\n    consistency: number\n  ): VoiceQuality {\n    // Weight factors for different aspects\n    const weights = {\n      stability: 0.4,\n      consistency: 0.3,\n      breathiness: 0.2,\n      vibrato: 0.1\n    };\n\n    let score = stability * weights.stability + consistency * weights.consistency;\n    \n    // Breathiness penalty (lower is better for breathiness)\n    if (breathiness !== null) {\n      score += (1 - Math.min(breathiness, 1)) * weights.breathiness;\n    } else {\n      score += 0.7 * weights.breathiness; // Neutral if no data\n    }\n    \n    // Vibrato bonus for controlled vibrato\n    if (vibrato.detected && vibrato.regularity > 0.7) {\n      score += 0.9 * weights.vibrato;\n    } else if (vibrato.detected) {\n      score += 0.6 * weights.vibrato;\n    } else {\n      score += 0.5 * weights.vibrato;\n    }\n\n    // Map score to quality levels\n    if (score >= 0.85) return VoiceQuality.EXCELLENT;\n    if (score >= 0.7) return VoiceQuality.GOOD;\n    if (score >= 0.5) return VoiceQuality.FAIR;\n    return VoiceQuality.POOR;\n  }\n\n  /**\n   * Generate recommendations based on analysis\n   */\n  private generateRecommendations(\n    quality: VoiceQuality,\n    stability: number,\n    vibrato: any,\n    breathiness: number | null,\n    consistency: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Stability recommendations\n    if (stability < 0.5) {\n      recommendations.push('音程の安定性を向上させるため、ゆっくりとした発声練習を行ってください');\n      recommendations.push('腹式呼吸を意識して、息の流れを一定に保つ練習をしてください');\n    } else if (stability < 0.7) {\n      recommendations.push('音程の微調整練習で、より正確なピッチコントロールを目指しましょう');\n    }\n\n    // Consistency recommendations\n    if (consistency < 0.5) {\n      recommendations.push('音量と音質の一貫性を保つため、定期的な発声練習を継続してください');\n      recommendations.push('録音を聞き返して、自分の声の特徴を把握しましょう');\n    }\n\n    // Breathiness recommendations\n    if (breathiness !== null && breathiness > 0.6) {\n      recommendations.push('声の息漏れが気になります。発声時の喉の締まりを意識してください');\n      recommendations.push('ハミング練習で、クリアな声質を目指しましょう');\n    }\n\n    // Vibrato recommendations\n    if (vibrato.detected) {\n      if (vibrato.regularity < 0.5) {\n        recommendations.push('ビブラートの規則性を改善するため、メトロノームに合わせた練習をしてください');\n      } else if (vibrato.rate > 7.5) {\n        recommendations.push('ビブラートの速度が速すぎます。よりゆったりとしたビブラートを練習してください');\n      }\n    } else if (quality === VoiceQuality.GOOD || quality === VoiceQuality.EXCELLENT) {\n      recommendations.push('美しいビブラートの習得に挑戦してみましょう');\n    }\n\n    // General recommendations based on quality\n    if (quality === VoiceQuality.POOR) {\n      recommendations.push('基礎的な発声練習から始めることをお勧めします');\n      recommendations.push('専門的な指導を受けることを検討してください');\n    } else if (quality === VoiceQuality.EXCELLENT) {\n      recommendations.push('素晴らしい声質です。この状態を維持する練習を続けてください');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Smooth frequency data using moving average\n   */\n  private smoothFrequencies(frequencies: number[], windowSize: number): number[] {\n    const smoothed: number[] = [];\n    \n    for (let i = 0; i < frequencies.length; i++) {\n      let sum = 0;\n      let count = 0;\n      \n      const start = Math.max(0, i - Math.floor(windowSize / 2));\n      const end = Math.min(frequencies.length, i + Math.floor(windowSize / 2) + 1);\n      \n      for (let j = start; j < end; j++) {\n        sum += frequencies[j];\n        count++;\n      }\n      \n      smoothed.push(sum / count);\n    }\n    \n    return smoothed;\n  }\n\n  /**\n   * Find local extrema (peaks and valleys) in frequency data\n   */\n  private findExtrema(data: number[]): Array<{ index: number; value: number; type: 'peak' | 'valley' }> {\n    const extrema: Array<{ index: number; value: number; type: 'peak' | 'valley' }> = [];\n    \n    for (let i = 1; i < data.length - 1; i++) {\n      const prev = data[i - 1];\n      const curr = data[i];\n      const next = data[i + 1];\n      \n      if (curr > prev && curr > next) {\n        extrema.push({ index: i, value: curr, type: 'peak' });\n      } else if (curr < prev && curr < next) {\n        extrema.push({ index: i, value: curr, type: 'valley' });\n      }\n    }\n    \n    return extrema;\n  }\n\n  /**\n   * Add data to analysis buffer\n   */\n  private addToBuffer(frequency: number, volume: number, clarity: number, timestamp: number): void {\n    this.analysisBuffer.push({ frequency, volume, clarity, timestamp });\n    \n    // Limit buffer size\n    if (this.analysisBuffer.length > 200) {\n      this.analysisBuffer.shift();\n    }\n  }\n\n  /**\n   * Clean old data from buffer\n   */\n  private cleanBuffer(currentTime: number): void {\n    const cutoffTime = currentTime - this.config.analysisWindowMs;\n    this.analysisBuffer = this.analysisBuffer.filter(entry => entry.timestamp > cutoffTime);\n  }\n\n  /**\n   * Reset analysis buffer\n   */\n  reset(): void {\n    this.analysisBuffer = [];\n  }\n\n  /**\n   * Get current buffer statistics\n   */\n  getBufferStats(): {\n    entryCount: number;\n    timeSpanMs: number;\n    averageVolume: number;\n    averageClarity: number;\n  } {\n    if (this.analysisBuffer.length === 0) {\n      return { entryCount: 0, timeSpanMs: 0, averageVolume: 0, averageClarity: 0 };\n    }\n\n    const volumes = this.analysisBuffer.map(entry => entry.volume);\n    const clarities = this.analysisBuffer.map(entry => entry.clarity);\n    const timeSpan = this.analysisBuffer[this.analysisBuffer.length - 1].timestamp - this.analysisBuffer[0].timestamp;\n\n    return {\n      entryCount: this.analysisBuffer.length,\n      timeSpanMs: timeSpan,\n      averageVolume: volumes.reduce((sum, vol) => sum + vol, 0) / volumes.length,\n      averageClarity: clarities.reduce((sum, clarity) => sum + clarity, 0) / clarities.length\n    };\n  }\n}","/**\n * CalibrationSystem - Device-specific audio calibration and optimization\n * \n * Automatically calibrates audio processing parameters based on device capabilities\n * Handles microphone sensitivity, noise characteristics, and frequency response\n */\n\nimport type { DeviceSpecs } from '../types';\nimport { DeviceDetection } from '../utils/DeviceDetection';\n\nexport class CalibrationSystem {\n  private deviceSpecs: DeviceSpecs;\n  private calibrationData: {\n    volumeOffset: number;\n    frequencyResponse: { [frequency: number]: number };\n    noiseProfile: { [frequency: number]: number };\n    optimalSettings: {\n      sensitivity: number;\n      noiseGate: number;\n      filterSettings: any;\n    };\n  } | null = null;\n\n  private isCalibrated = false;\n  private calibrationInProgress = false;\n\n  constructor() {\n    this.deviceSpecs = DeviceDetection.getDeviceSpecs();\n  }\n\n  /**\n   * Perform automatic calibration\n   */\n  async calibrate(audioContext: AudioContext, mediaStream: MediaStream): Promise<{\n    success: boolean;\n    calibrationData: any;\n    recommendedSettings: any;\n    error?: Error;\n  }> {\n    if (this.calibrationInProgress) {\n      throw new Error('Calibration already in progress');\n    }\n\n    this.calibrationInProgress = true;\n\n    try {\n      console.log('🎛️ [CalibrationSystem] Starting device calibration');\n\n      // Step 1: Measure background noise\n      const noiseProfile = await this.measureBackgroundNoise(audioContext, mediaStream);\n\n      // Step 2: Calibrate volume levels\n      const volumeCalibration = await this.calibrateVolumeLevels(audioContext, mediaStream);\n\n      // Step 3: Measure frequency response (simplified)\n      const frequencyResponse = await this.measureFrequencyResponse(audioContext, mediaStream);\n\n      // Step 4: Determine optimal settings\n      const optimalSettings = this.calculateOptimalSettings(\n        noiseProfile,\n        volumeCalibration,\n        frequencyResponse\n      );\n\n      this.calibrationData = {\n        volumeOffset: volumeCalibration.offset,\n        frequencyResponse,\n        noiseProfile,\n        optimalSettings\n      };\n\n      this.isCalibrated = true;\n      this.calibrationInProgress = false;\n\n      console.log('✅ [CalibrationSystem] Calibration completed successfully');\n\n      return {\n        success: true,\n        calibrationData: this.calibrationData,\n        recommendedSettings: optimalSettings\n      };\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Calibration failed:', error);\n      this.calibrationInProgress = false;\n      \n      return {\n        success: false,\n        calibrationData: null,\n        recommendedSettings: this.getDefaultSettings(),\n        error: error as Error\n      };\n    }\n  }\n\n  /**\n   * Measure background noise levels\n   */\n  private async measureBackgroundNoise(\n    audioContext: AudioContext,\n    mediaStream: MediaStream,\n    durationMs: number = 2000\n  ): Promise<{ [frequency: number]: number }> {\n    return new Promise((resolve) => {\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 2048;\n      \n      const source = audioContext.createMediaStreamSource(mediaStream);\n      source.connect(analyser);\n\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Float32Array(bufferLength);\n      const measurements: Float32Array[] = [];\n\n      const startTime = Date.now();\n\n      const measureNoise = () => {\n        if (Date.now() - startTime >= durationMs) {\n          // Calculate average noise profile\n          const avgNoise: { [frequency: number]: number } = {};\n          \n          for (let bin = 0; bin < bufferLength; bin++) {\n            const frequency = (bin * audioContext.sampleRate) / (analyser.fftSize);\n            let sum = 0;\n            \n            for (const measurement of measurements) {\n              sum += measurement[bin];\n            }\n            \n            avgNoise[Math.round(frequency)] = sum / measurements.length;\n          }\n\n          source.disconnect();\n          resolve(avgNoise);\n          return;\n        }\n\n        analyser.getFloatFrequencyData(dataArray);\n        measurements.push(new Float32Array(dataArray));\n        \n        setTimeout(measureNoise, 100);\n      };\n\n      measureNoise();\n    });\n  }\n\n  /**\n   * Calibrate volume levels\n   */\n  private async calibrateVolumeLevels(\n    audioContext: AudioContext,\n    mediaStream: MediaStream,\n    durationMs: number = 3000\n  ): Promise<{ offset: number; range: { min: number; max: number } }> {\n    return new Promise((resolve) => {\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 1024;\n      \n      const source = audioContext.createMediaStreamSource(mediaStream);\n      source.connect(analyser);\n\n      const bufferLength = analyser.fftSize;\n      const dataArray = new Float32Array(bufferLength);\n      const volumeMeasurements: number[] = [];\n\n      const startTime = Date.now();\n\n      const measureVolume = () => {\n        if (Date.now() - startTime >= durationMs) {\n          // Analyze volume distribution\n          volumeMeasurements.sort((a, b) => a - b);\n          \n          const min = volumeMeasurements[0] || 0;\n          const max = volumeMeasurements[volumeMeasurements.length - 1] || 1;\n          const median = volumeMeasurements[Math.floor(volumeMeasurements.length / 2)] || 0.5;\n          \n          // Calculate offset to center dynamic range\n          const targetCenter = 0.3; // Aim for 30% as comfortable speaking level\n          const offset = targetCenter - median;\n\n          source.disconnect();\n          resolve({\n            offset,\n            range: { min, max }\n          });\n          return;\n        }\n\n        analyser.getFloatTimeDomainData(dataArray);\n        \n        // Calculate RMS\n        let sum = 0;\n        for (let i = 0; i < bufferLength; i++) {\n          sum += dataArray[i] * dataArray[i];\n        }\n        const rms = Math.sqrt(sum / bufferLength);\n        volumeMeasurements.push(rms);\n        \n        setTimeout(measureVolume, 50);\n      };\n\n      measureVolume();\n    });\n  }\n\n  /**\n   * Measure frequency response (simplified version)\n   */\n  private async measureFrequencyResponse(\n    audioContext: AudioContext,\n    mediaStream: MediaStream,\n    durationMs: number = 5000\n  ): Promise<{ [frequency: number]: number }> {\n    return new Promise((resolve) => {\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 4096;\n      \n      const source = audioContext.createMediaStreamSource(mediaStream);\n      source.connect(analyser);\n\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Float32Array(bufferLength);\n      const responseMap: { [frequency: number]: number[] } = {};\n\n      const startTime = Date.now();\n\n      const measureResponse = () => {\n        if (Date.now() - startTime >= durationMs) {\n          // Calculate average response for each frequency\n          const avgResponse: { [frequency: number]: number } = {};\n          \n          Object.keys(responseMap).forEach(freqStr => {\n            const frequency = parseInt(freqStr);\n            const measurements = responseMap[frequency];\n            const avg = measurements.reduce((sum, val) => sum + val, 0) / measurements.length;\n            avgResponse[frequency] = avg;\n          });\n\n          source.disconnect();\n          resolve(avgResponse);\n          return;\n        }\n\n        analyser.getFloatFrequencyData(dataArray);\n        \n        // Store measurements for key frequencies\n        for (let bin = 0; bin < bufferLength; bin++) {\n          const frequency = Math.round((bin * audioContext.sampleRate) / (analyser.fftSize));\n          \n          // Focus on vocal range\n          if (frequency >= 80 && frequency <= 1000) {\n            if (!responseMap[frequency]) {\n              responseMap[frequency] = [];\n            }\n            responseMap[frequency].push(dataArray[bin]);\n          }\n        }\n        \n        setTimeout(measureResponse, 100);\n      };\n\n      measureResponse();\n    });\n  }\n\n  /**\n   * Calculate optimal settings based on calibration data\n   */\n  private calculateOptimalSettings(\n    noiseProfile: { [frequency: number]: number },\n    volumeCalibration: any,\n    frequencyResponse: { [frequency: number]: number }\n  ): any {\n    const baseSettings = this.getDefaultSettings();\n\n    // Adjust sensitivity based on volume calibration\n    const sensitivityAdjustment = Math.max(0.5, Math.min(2.0, 1.0 - volumeCalibration.offset));\n    const adjustedSensitivity = baseSettings.sensitivity * sensitivityAdjustment;\n\n    // Adjust noise gate based on background noise\n    const noiseFrequencies = Object.keys(noiseProfile).map(f => parseInt(f));\n    const vocalRangeNoise = noiseFrequencies\n      .filter(f => f >= 100 && f <= 800)\n      .map(f => noiseProfile[f]);\n    \n    const avgNoise = vocalRangeNoise.length > 0 ? \n      vocalRangeNoise.reduce((sum, val) => sum + val, 0) / vocalRangeNoise.length : -60;\n    \n    const noiseGateAdjustment = Math.max(-20, avgNoise + 10); // 10dB above average noise\n    const adjustedNoiseGate = Math.max(baseSettings.noiseGate, Math.abs(noiseGateAdjustment) / 1000);\n\n    // Analyze frequency response for filter adjustments\n    const frequencyKeys = Object.keys(frequencyResponse).map(f => parseInt(f)).sort((a, b) => a - b);\n    const responseLevels = frequencyKeys.map(f => frequencyResponse[f]);\n    \n    // Simple frequency response correction\n    const lowFreqResponse = responseLevels.slice(0, Math.floor(responseLevels.length * 0.3));\n    const midFreqResponse = responseLevels.slice(\n      Math.floor(responseLevels.length * 0.3),\n      Math.floor(responseLevels.length * 0.7)\n    );\n    const highFreqResponse = responseLevels.slice(Math.floor(responseLevels.length * 0.7));\n\n    const lowAvg = lowFreqResponse.reduce((sum, val) => sum + val, 0) / lowFreqResponse.length;\n    const midAvg = midFreqResponse.reduce((sum, val) => sum + val, 0) / midFreqResponse.length;\n    const highAvg = highFreqResponse.reduce((sum, val) => sum + val, 0) / highFreqResponse.length;\n\n    return {\n      sensitivity: Math.round(adjustedSensitivity * 10) / 10,\n      noiseGate: Math.round(adjustedNoiseGate * 1000) / 1000,\n      volumeOffset: volumeCalibration.offset,\n      filterSettings: {\n        highpassFreq: lowAvg < (midAvg - 5) ? 100 : 80, // Stronger highpass if low freq is weak\n        lowpassFreq: highAvg > (midAvg + 3) ? 600 : 800, // Lower cutoff if high freq is strong\n        notchFreq: 60, // Standard power line frequency\n        highpassQ: 0.7,\n        lowpassQ: 0.7,\n        notchQ: 10.0\n      },\n      deviceAdjustments: {\n        lowFreqCompensation: Math.max(0.8, Math.min(1.5, midAvg / (lowAvg || -60))),\n        highFreqCompensation: Math.max(0.8, Math.min(1.2, midAvg / (highAvg || -60)))\n      }\n    };\n  }\n\n  /**\n   * Get default settings for current device\n   */\n  private getDefaultSettings(): any {\n    return {\n      sensitivity: this.deviceSpecs.sensitivity,\n      noiseGate: this.deviceSpecs.noiseGate,\n      volumeOffset: 0,\n      filterSettings: {\n        highpassFreq: 80,\n        lowpassFreq: 800,\n        notchFreq: 60,\n        highpassQ: 0.7,\n        lowpassQ: 0.7,\n        notchQ: 10.0\n      }\n    };\n  }\n\n  /**\n   * Apply calibrated settings to audio processing\n   */\n  applyCalibration(audioProcessor: any): boolean {\n    if (!this.isCalibrated || !this.calibrationData) {\n      console.warn('⚠️ [CalibrationSystem] No calibration data available');\n      return false;\n    }\n\n    try {\n      const settings = this.calibrationData.optimalSettings;\n      \n      // Apply settings to audio processor\n      if (audioProcessor.setSensitivity) {\n        audioProcessor.setSensitivity(settings.sensitivity);\n      }\n      \n      if (audioProcessor.setNoiseGate) {\n        audioProcessor.setNoiseGate(settings.noiseGate);\n      }\n      \n      if (audioProcessor.updateFilterSettings) {\n        audioProcessor.updateFilterSettings(settings.filterSettings);\n      }\n\n      console.log('✅ [CalibrationSystem] Calibration applied successfully');\n      return true;\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Failed to apply calibration:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get calibration status\n   */\n  getCalibrationStatus(): {\n    isCalibrated: boolean;\n    inProgress: boolean;\n    deviceSpecs: DeviceSpecs;\n    calibrationData: any;\n  } {\n    return {\n      isCalibrated: this.isCalibrated,\n      inProgress: this.calibrationInProgress,\n      deviceSpecs: this.deviceSpecs,\n      calibrationData: this.calibrationData\n    };\n  }\n\n  /**\n   * Reset calibration\n   */\n  reset(): void {\n    this.isCalibrated = false;\n    this.calibrationInProgress = false;\n    this.calibrationData = null;\n    \n    console.log('🔄 [CalibrationSystem] Calibration reset');\n  }\n\n  /**\n   * Save calibration data to localStorage\n   */\n  saveCalibration(): boolean {\n    if (!this.isCalibrated || !this.calibrationData) {\n      return false;\n    }\n\n    try {\n      const calibrationKey = `pitchpro_calibration_${this.deviceSpecs.deviceType}`;\n      const dataToSave = {\n        deviceSpecs: this.deviceSpecs,\n        calibrationData: this.calibrationData,\n        timestamp: Date.now()\n      };\n\n      localStorage.setItem(calibrationKey, JSON.stringify(dataToSave));\n      console.log('💾 [CalibrationSystem] Calibration saved');\n      return true;\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Failed to save calibration:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Load calibration data from localStorage\n   */\n  loadCalibration(): boolean {\n    try {\n      const calibrationKey = `pitchpro_calibration_${this.deviceSpecs.deviceType}`;\n      const savedData = localStorage.getItem(calibrationKey);\n      \n      if (!savedData) {\n        return false;\n      }\n\n      const parsedData = JSON.parse(savedData);\n      \n      // Check if calibration is recent (within 7 days)\n      const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n      if (Date.now() - parsedData.timestamp > maxAge) {\n        console.log('⏰ [CalibrationSystem] Saved calibration is too old, ignoring');\n        return false;\n      }\n\n      // Verify device compatibility\n      if (parsedData.deviceSpecs.deviceType !== this.deviceSpecs.deviceType) {\n        console.log('📱 [CalibrationSystem] Device type mismatch, ignoring saved calibration');\n        return false;\n      }\n\n      this.calibrationData = parsedData.calibrationData;\n      this.isCalibrated = true;\n      \n      console.log('📂 [CalibrationSystem] Calibration loaded successfully');\n      return true;\n\n    } catch (error) {\n      console.error('❌ [CalibrationSystem] Failed to load calibration:', error);\n      return false;\n    }\n  }\n}"],"names":["HarmonicCorrection","config","frequency","volume","now","analysis","recentFrequencies","entry","fundamentalCandidates","bestCandidate","candidate","confidence","candidates","harmonicNum","fundamental","exactHarmonic","centDeviation","likelihood","a","b","_harmonicNumber","totalConfidence","validMeasurements","freq","closestHarmonicNum","expectedFreq","avgConfidence","stabilityBonus","timestamp","volumeConfidence","stabilityConfidence","lastFreq","freqRatio","currentTime","cutoffTime","frequencies","confidences","sum","conf","minFreq","maxFreq","mean","variance","coefficientOfVariation","stabilityScore","newConfig","VoiceQuality","VoiceAnalyzer","clarity","spectralData","stability","vibrato","breathiness","consistency","quality","recommendations","validFrequencies","deviationCents","f","smoothed","extrema","timeSpan","rate","depths","i","freq1","freq2","cents","averageDepth","depth","periods","period","regularity","periodMean","p","periodVariance","fundamentalBin","noiseBins","fundamentalEnergy","val","noiseEnergy","noiseRatio","volumes","clarities","volumeConsistency","clarityConsistency","values","weights","score","windowSize","count","start","end","j","data","prev","curr","next","vol","CalibrationSystem","DeviceDetection","audioContext","mediaStream","noiseProfile","volumeCalibration","frequencyResponse","optimalSettings","error","durationMs","resolve","analyser","source","bufferLength","dataArray","measurements","startTime","measureNoise","avgNoise","bin","measurement","volumeMeasurements","measureVolume","min","max","offset","rms","responseMap","measureResponse","avgResponse","freqStr","avg","baseSettings","sensitivityAdjustment","adjustedSensitivity","vocalRangeNoise","noiseGateAdjustment","adjustedNoiseGate","responseLevels","lowFreqResponse","midFreqResponse","highFreqResponse","lowAvg","midAvg","highAvg","audioProcessor","settings","calibrationKey","dataToSave","savedData","parsedData","maxAge"],"mappings":"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"}