🔴 根本的な問題
問題の本質
// innerHTML 後、document.scripts には以下が含まれる:
// 1. index.html の head スクリプト（既に実行済み）
// 2. テンプレートのスクリプト（innerHTML で追加、未実行）

// 現在のチェックは「2」も「既に読み込み済み」と誤判定する
const alreadyLoaded = Array.from(document.scripts).some(existingScript => {
    // ... 自分自身も含めて検索してしまう
});
チェックが区別できないもの
1. 実行済みスクリプト（head から読み込み済み）→ スキップすべき
2. 未実行スクリプト（innerHTML で追加直後）→ 実行すべき

🛠️ 推奨修正案（精査版）
案A: 実行済みスクリプトを明示的に追跡（最も安全）
class SimpleRouter {
    constructor() {
        // 実行済みスクリプトURLを追跡
        this.executedScripts = new Set();
        // ... 既存コード
    }

    async loadPage(page, fullHash = '', signal = null) {
        // ... 既存コード（innerHTML まで）

        const scriptTags = this.appRoot.querySelectorAll('script');
        scriptTags.forEach(oldScript => {
            const scriptSrc = oldScript.getAttribute('src');
            
            if (scriptSrc) {
                const baseSrc = scriptSrc.split('?')[0];
                
                // 実行済みセットでチェック（document.scripts ではなく）
                if (this.executedScripts.has(baseSrc)) {
                    console.log(`⏭️ [Router] スクリプト既実行済み、スキップ: ${baseSrc}`);
                    oldScript.remove();
                    return;
                }
                
                // これから実行するので追跡に追加
                this.executedScripts.add(baseSrc);
            }
            
            // 既存の replaceChild 処理...
            const newScript = document.createElement('script');
            Array.from(oldScript.attributes).forEach(attr => {
                newScript.setAttribute(attr.name, attr.value);
            });
            newScript.textContent = oldScript.textContent;
            oldScript.parentNode.replaceChild(newScript, oldScript);
        });
        // ...
    }
}
利点:
* 「実行した」という事実を明示的に追跡
* innerHTML 直後の未実行スクリプトは追跡に入っていない
* シンプルで理解しやすい
注意点:
* executedScripts はページリロードでリセットされる（正しい動作）
* SPA内の再ナビゲーションでは保持される（正しい動作）
案B: index.html の head スクリプトのみチェック
// loadPage メソッド内で使用
const headScripts = document.querySelectorAll('head script[src]');
const headScriptSrcs = new Set(
    Array.from(headScripts).map(s => s.getAttribute('src')?.split('?')[0])
);

scriptTags.forEach(oldScript => {
    const scriptSrc = oldScript.getAttribute('src');
    
    if (scriptSrc) {
        const baseSrc = scriptSrc.split('?')[0];
        
        // head のスクリプトのみチェック（テンプレート自身は含まない）
        if (headScriptSrcs.has(baseSrc)) {
            console.log(`⏭️ [Router] head で読み込み済み、スキップ: ${baseSrc}`);
            oldScript.remove();
            return;
        }
    }
    // ...
});
利点:
* head スクリプトは確実に実行済み
* テンプレートスクリプトは常に実行される
欠点:
* 再ナビゲーション問題を解決しない
* preparation → training → preparation で依然としてエラー
案C: 初回実行フラグを使用
scriptTags.forEach(oldScript => {
    const scriptSrc = oldScript.getAttribute('src');
    
    if (scriptSrc) {
        const baseSrc = scriptSrc.split('?')[0];
        const flagKey = `script_executed_${baseSrc.replace(/\//g, '_')}`;
        
        // sessionStorage で実行済みかチェック
        if (sessionStorage.getItem(flagKey) === 'true') {
            console.log(`⏭️ [Router] スクリプト既実行済み、スキップ: ${baseSrc}`);
            oldScript.remove();
            return;
        }
        
        // 実行フラグを設定
        sessionStorage.setItem(flagKey, 'true');
    }
    // ...
});
利点:
* NavigationManager の既存パターンと一貫性がある
* リロード時は sessionStorage がリセットされる
欠点:
* sessionStorage の汚染
* クリーンアップが必要

✅ 推奨: 案A（実行済みスクリプト追跡）
理由:
1. シンプル: クラス内プロパティで完結
2. 正確: 実行事実を追跡するので誤判定なし
3. 自然なリセット: ページリロードでインスタンス再作成 → Set リセット
4. NavigationManager との相性: 独立した仕組みで競合しない

📊 シナリオ別検証（修正後）
シナリオ	期待動作	案A結果
home → preparation（初回）	スクリプト実行	✅
preparation → training	スクリプト実行	✅
training → preparation（再訪問）	スクリプトスキップ	✅
preparation リロード	リダイレクト（NavigationManager）	✅
training リロード	PitchPro委譲、スクリプト再実行	✅
ダイレクトアクセス	リダイレクト（NavigationManager）	✅
ブラウザバック	制御（NavigationManager）	✅
🎯 結論
項目	現在の修正	推奨修正（案A）
初回ナビゲーション	❌ 壊れる	✅ 動作
再ナビゲーション	✅ 動作する可能性	✅ 確実に動作
リロード	✅ NavigationManagerで保護	✅
ダイレクトアクセス	✅ NavigationManagerで保護	✅
ブラウザバック	✅ NavigationManagerで保護	✅
ES6モジュール対応	⚠️ 不確定	✅ 明示的対応可能
推奨アクション: 現在の修正をマージせず、案Aの実装に変更することを強く推奨します。
